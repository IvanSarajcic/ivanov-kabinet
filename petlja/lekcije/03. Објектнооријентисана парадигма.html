<div id="lectureContent-8238" class="lectureContentMaterial active">



    
  <section id="id1">
<h1>Објектно–оријентисана парадигма<a class="headerlink" href="#id1" title="Permalink to this heading" target="_blank">¶</a></h1>
<p>Објектно–оријентисану парадигму сте веома детаљно изучили у трећем
разреду у предмету Објектно-оријентисано програмирање, па се нећемо
пуно задржавати на њеном описивању.</p>
<p>Објектно–оријентисана парадигма (ООП) је модел програмирања који се
темељи на организовању и структуирању кода око „објеката”, који су
инстанциране представе стварних ентитета (на пример, аутомобил,
штампач, запослени) или апстрактних концепта (на пример, датотека,
израз). ООП промовише начин размишљања о програмима као колекцији
објеката који међусобно комуницирају путем дефинисаних
интеракција. Објекти једни другима шаљу поруке (тако што позивају
методе које су део јавног интерфејса). Ова парадигма пружа низ
предности као што су модуларност, поновно коришћење кода, лакше
одржавање и разумевање, те олакшава развој комплексних система.  ООП
омогућава организацију кода на начин који одражава стварни свет и
олакшава развој скалабилних и одрживих апликација. Објектно
оријентисана парадигма је веома брзо прихваћена у софтверској
индустрији и може се рећи да је данас вероватно и доминантна
парадигма. ООП се данас примењује у многим програмским језицима као
што су <strong>Java</strong>, <strong>Python</strong>, <strong>C++</strong>, <strong>C#</strong>, <strong>Ruby</strong> итд.</p>
<p>Слично као и струтурно програмирање и објектно-оријентисано
програмирање је настало као одговор на софтверску кризу. Разбијањем
монолитних програма у независне целине (класе и објекте), омогућено је
да више програмера и тимова програмера подели посао тако да софтверске
компоненте које независно програмирају комуницирају само договореног
јавног интерфејса. На тај начин један програмер не мора (а коришћењем
концепта енкапсулације и не може) да зна на који начин је
имплементирана компонента коју други програмер програмира. То даје
слободу другом програмеру да у било ком тренутку замени унутрашњу
имплементацију (на пример, употреби неки ефикаснији алгоритам или
структуре података), а да други програмери због тога не морају да
мењају свој кôд. Додатно, једном испрограмиране класе се могу
користити у већем броју различитих програма (на пример, класа за
представљање времена и датума, класа за представљање листа
тј. динамички проширивих низова или класа за представљање дугмета на
корисничком интерфејсу). Механизам наслеђивања даје могућност да се
класе прошире и на тај начин прилагоде новим, сложенијим захтевима.
На пример, класа којом се представљају електрични аутомобили може да
наследи класу којом се предсављају аутомобили, додајући податке о
батерији. Полиморфизам омогућава да се се програмирање неких
компонената врши само према апстрактном интерфејсу других
поткомпонената, а да се те поткомпоненте накнадно замене новим
конкретним имплементацијама. Тако, на пример, програм за обраду текста
може да нуди функционалност штампања, обраћајући се апстрактној класи
тј. интерфејсу који нуди заједничке функционалности за све
штампаче. Оваквом систему у било ком тренутку може бити додата класа
којом се представља неки нови, конкретни штампач, док год та класа
имплементира све функционалности тог заједничког интерфејса.</p>
<p>Подсетимо се још једном кључних концепата ООП, које сте проучавали у
трећем разреду:</p>
<ol class="arabic">
<li><p><strong>Објекти:</strong> Објекти су инстанце класа које дефинишу својства
(атрибуте) и понашање (методе). На пример, у апликацији за
управљање корисницима, сваки корисник може бити представљен као
објекат са својим атрибутима као што су име, мејл адреса и старост.</p></li>
<li><p><strong>Класе:</strong> Класе су шаблони који дефинишу структуру и понашање
објеката. Оне садрже дефиниције атрибута и метода које ће објекти
имати. На пример, „Корисник” може бити класа која дефинише својства
и методе заједничке свим корисницима.</p></li>
<li><p><strong>Енкапсулација</strong> се односи на паковање података (атрибута) и
функционалности (метода) унутар једног ентитета - објекта. Идеја је
да се објекти делују као „капсуле” које садрже своје унутрашње
стање и операције, док су детаљи имплементације скривени од
спољашњег света тј. од програмера који користе класе и
објекте. Енкапсулација омогућава да се приступ и баратање
подацима врше само путем добро дефинисаних метода, чиме се
осигурава конзистентно стање објекта и смањује ризик од нежељених
модификација.</p>
<p>Предности енкапсулације укључују:</p>
<p><em>Скривање детаља имплементације:</em> Енкапсулација омогућава да се
промене у унутрашњој имплементацији објекта изврше без утицаја на
кориснике тог објекта. Корисници само користе јавне методе за
интеракцију са објектима, док је комплексност детаља сакривена.</p>
<p><em>Заштита и валидација:</em> Објекти могу примењивати правила за приступ
и манипулацију подацима. Ово омогућава да се валидира унос података
и да се осигура њихова исправност пре него што буду записани.</p>
<p><em>Модуларност и поновно коришћење:</em> Енкапсулација омогућава
развијање модула који се могу користити независно од других делова
апликације. Објекти се могу поновно користити у различитим
контекстима, смањујући потребу за писањем истог кода више пута.</p>
<p><em>Одржавање и рефакторисање:</em> Промене у имплементацији објекта могу
се обавити унутар саме капсуле без утицаја на остатак система. Ово
олакшава одржавање и рефакторисање кода.</p>
<p><em>Смањење грешака:</em> Енкапсулација смањује могућност грешака јер се
манипулација подацима обавља само путем строго дефинисаних метода
које су тестиране и верификоване.</p>
<p>Да би се постигла енкапсулација, програмски језици омогућавају
дефинисање приступних модификатора који контролишу видљивост
атрибута и метода изван објекта. Приступни модификатори омогућавају
програмерима да прецизно дефинишу који делови објекта су доступни
изван њега, чиме се имплементира принцип енкапсулације.</p>
</li>
</ol>
<p>Подсетимо се ових концепата кроз следећи једноставан пример.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="nn">System</span><span class="p">;</span>

<span class="k">public</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Circle</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// privatno polje u kom čuvamo poluprečnik</span>
<span class="w">    </span><span class="k">private</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">radius</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// konstruktor</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="nf">Circle</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">radius</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="n">setRadius</span><span class="p">(</span><span class="n">radius</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Metod za čitanje poluprečnika</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="nf">GetRadius</span><span class="p">()</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">radius</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Metod za promenu poluprečnika</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">SetRadius</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">newRadius</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// obezbeđujemo da poluprečnik ne bude negativan</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">radius</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">            </span><span class="k">this</span><span class="p">.</span><span class="n">radius</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">radius</span><span class="p">;</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">            </span><span class="k">throw</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nf">ArgumentException</span><span class="p">(</span><span class="s">"Poluprečnik ne može biti negativan."</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Metod za izračunavanje površine</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="nf">CalculateArea</span><span class="p">()</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">radius</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">radius</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">Math</span><span class="p">.</span><span class="n">PI</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Metod za izračunavanje obima</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="nf">CalculateCircumference</span><span class="p">()</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">radius</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">Math</span><span class="p">.</span><span class="n">PI</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Program</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">Main</span><span class="p">()</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Kreiramo objekat, instancu klase krug</span>
<span class="w">        </span><span class="n">Circle</span><span class="w"> </span><span class="n">circle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Circle</span><span class="p">(</span><span class="mf">5.0</span><span class="p">);</span>

<span class="w">        </span><span class="c1">// Menjamo mu poluprečnik</span>
<span class="w">        </span><span class="n">circle</span><span class="p">.</span><span class="n">SetRadius</span><span class="p">(</span><span class="mf">7.0</span><span class="p">);</span>

<span class="w">        </span><span class="c1">// Računamo i ispisujemo poluprečnik, površinu i obim</span>
<span class="w">        </span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">$"Radius: {circle.GetRadius()}"</span><span class="p">);</span>
<span class="w">        </span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">$"Area: {circle.CalculateArea()}"</span><span class="p">);</span>
<span class="w">        </span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">$"Circumference: {circle.CalculateCircumference()}"</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<ol class="arabic" start="4">
<li><p><strong>Наслеђивање:</strong> Наслеђивање омогућава креирање нових класа на
основу већ постојећих класа. Ова парадигма подржава идеју да нове
класе могу наследити (преузети) интерфејс тј. својства и методе
постојећих класа, чиме се олакшава поновно коришћење кода и
организација структуре.</p>
<p><em>Базна Класа:</em> Базна класа је оригинална класа која дефинише
својства и методе које ће бити наслеђене. Ова класа се такође
назива и родитељском класом, надкласом или суперкласом.</p>
<p><em>Изведена Класа:</em> Изведена класа је нова класа која се креира на
основу постојеће класе. Ова класа наслеђује својства и методе базне
класе, али може додати своје додатне карактеристике или
предефинисати постојеће методе.</p>
<p><em>Наслеђивање атрибута и метода:</em> Изведена класа аутоматски
наслеђује све атрибуте (својства) и методе (укључујући и њихову
имплементацију) дефинисане у базној класи. То омогућава да се
сличне класе репрезентују на логичан и организован начин.</p>
<p><em>Додатни атрибути и методи:</em> Изведена класа може додати нове методе
и атрибути који нису присутни у базној класи. Ово омогућава да се
прошири функционалност и додају нове карактеристике без утицаја на
базну класу.</p>
<p><em>Предефинисање Метода:</em> Изведена класа може предефинисати
(енгл. override) методе базне класе тако да се прилагоде
специфичним потребама. Ово омогућава да се исте методе понашају
другачије у различитим контекстима.</p>
<p><em>Вишеструко наслеђивање (у одређеним језицима):</em> Неки програмски
језици подржавају вишеструко наслеђивање, што значи да изведена
класа може наследити својства и методе из више базних
класа. Међутим, ова функционалност може постати комплексна и
довести до „дијамантског проблема” у неким случајевима.</p>
<p>Наслеђивање омогућава ефикасно поновно коришћење кода, јер се
постојеће имплементације могу користити као основа за нове
класе. Ово олакшава организацију, одржавање и разумевање кода, јер
се сличне класе групишу заједно, а заједнички код се дели.</p>
</li>
<li><p><strong>Полиморфизам:</strong> Полиморфизам омогућава истоименим методама да се
понашају различито у зависности од класе којој припадају тј.
омогућава различитим објектима да се понашају на различите начине,
чак и ако деле исти назив методе. Полиморфизам омогућава да се иста
метода користи за различите типове објеката, чиме се
поједностављује кôд и олакшава рад са разноликим ентитетима.</p>
<p>Полиморфизам омогућава и да класа има методе са истим именом, али
са различитим потписима.</p>
<p><em>Предефинисање метода</em>: Када изведена класа наслеђује методу од
своје базне класе, може предефинисати (override) ту методу да би се
прилагодила свом специфичном понашању. Ово омогућава да метода има
другачији садржај у различитим класама.</p>
<p><em>Динамичко везивање</em>: Полиморфизам омогућава да се одабере права
верзија методе током извршавања, а не током компилације. Ово се
назива динамичко повезивање или касно повезивање, и омогућава да се
изабере права метода на основу стварног типа објекта који се
обрађује.</p>
<p><em>Интерфејси и апстрактне класе</em>: Полиморфизам често се постиже кроз
употребу интерфејса и апстрактних класа. Интерфејси дефинишу скуп
метода које се морају имплементирати у изведеним класама, док
апстрактне класе садрже недефинисане методе које се морају
имплементирати у конкретним подкласама.</p>
<p><em>Поједностављена комуникација</em>: Полиморфизам омогућава да се исте
операције примењују на различите типове објеката без потребе за
анализом њиховог типа наредбама гранања. На пример, ако имате
различите геометријске облике, можете користити исту методу за
израчунавање површине без обзира на то који облик користите.</p>
<p>Полиморфизам чини код флексибилнијим, омогућавајући програмерима да
раде са различитим типовима објеката користећи исте методе и
интерфејс.</p>
</li>
</ol>
<p>Подсетимо се наслеђивања и полиморфизма тако што ћемо увести
апстрактну класу за облике.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="nn">System</span><span class="p">;</span>

<span class="c1">// Apstraktna bazna klasa za predstavljanje bilo kog oblika</span>
<span class="k">public</span><span class="w"> </span><span class="k">abstract</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Shape</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// apstraktna metoda za izračunavanje površine</span>
<span class="w">    </span><span class="c1">// (potrebno je da se implementira u svim izvedenim klasama)</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="k">abstract</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="nf">CalculateArea</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// Izvedena klasa za predstavljanje krugova</span>
<span class="c1">// Krug je vrsta oblika, pa klasa Circle nasleđuje klasu Shape</span>
<span class="k">public</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Circle</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">Shape</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// poluprečnik</span>
<span class="w">    </span><span class="k">private</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">radius</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Konstruktor</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="nf">Circle</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">radius</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="n">radius</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">radius</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Implementacija izračunavanja površine</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="nf">CalculateArea</span><span class="p">()</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">Math</span><span class="p">.</span><span class="n">PI</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">radius</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">radius</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Izvedena klasa za predstavljanje pravougaonika</span>
<span class="c1">// Pravougaonik je vrsta oblika, pa klasa Rectangle nasleđuje klasu Shape</span>
<span class="k">public</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Rectangle</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">Shape</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Dužina i širina</span>
<span class="w">    </span><span class="k">private</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">width</span><span class="p">;</span>
<span class="w">    </span><span class="k">private</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">height</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Konstruktor</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="nf">Rectangle</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">height</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="n">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">width</span><span class="p">;</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="n">height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">height</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Implementacija izračunavanja površine</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="nf">CalculateArea</span><span class="p">()</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">width</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">height</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Program</span>
<span class="p">{</span>
<span class="w">   </span><span class="k">static</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">Main</span><span class="p">()</span>
<span class="w">   </span><span class="p">{</span>
<span class="w">       </span><span class="c1">// Niz oblika</span>
<span class="w">       </span><span class="n">Shape</span><span class="p">[]</span><span class="w"> </span><span class="n">shapes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Shape</span><span class="p">[]</span>
<span class="w">       </span><span class="p">{</span>
<span class="w">           </span><span class="k">new</span><span class="w"> </span><span class="nf">Circle</span><span class="p">(</span><span class="mf">5.0</span><span class="p">),</span>
<span class="w">           </span><span class="k">new</span><span class="w"> </span><span class="nf">Rectangle</span><span class="p">(</span><span class="mf">4.0</span><span class="p">,</span><span class="w"> </span><span class="mf">6.0</span><span class="p">),</span>
<span class="w">           </span><span class="k">new</span><span class="w"> </span><span class="nf">Circle</span><span class="p">(</span><span class="mf">3.5</span><span class="p">),</span>
<span class="w">           </span><span class="k">new</span><span class="w"> </span><span class="nf">Rectangle</span><span class="p">(</span><span class="mf">2.0</span><span class="p">,</span><span class="w"> </span><span class="mf">8.0</span><span class="p">)</span>
<span class="w">       </span><span class="p">};</span>

<span class="w">       </span><span class="c1">// Izračunavanje ukupne površine</span>
<span class="w">       </span><span class="kt">double</span><span class="w"> </span><span class="n">totalArea</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span>
<span class="w">       </span><span class="k">foreach</span><span class="w"> </span><span class="p">(</span><span class="n">Shape</span><span class="w"> </span><span class="n">shape</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">shapes</span><span class="p">)</span>
<span class="w">           </span><span class="n">totalArea</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">shape</span><span class="p">.</span><span class="n">CalculateArea</span><span class="p">();</span>

<span class="w">       </span><span class="c1">// Ispis ukupne površine</span>
<span class="w">       </span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">$"Total Area of Shapes: {totalArea}"</span><span class="p">);</span>
<span class="w">   </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Упоредимо овај програм са еквивалентним програмом написаном у духу
императивне парадигме.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Program</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">Circle</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">public</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">radius</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="nf">CircleArea</span><span class="p">(</span><span class="n">Circle</span><span class="w"> </span><span class="n">circle</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">circle</span><span class="p">.</span><span class="n">radius</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">circle</span><span class="p">.</span><span class="n">radius</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">Math</span><span class="p">.</span><span class="n">PI</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">Rectangle</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">public</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="nf">RectangleArea</span><span class="p">(</span><span class="n">Rectangle</span><span class="w"> </span><span class="n">rectangle</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">rectangle</span><span class="p">.</span><span class="n">width</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">rectangle</span><span class="p">.</span><span class="n">height</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">Main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">Circle</span><span class="w"> </span><span class="n">circle1</span><span class="p">;</span><span class="w"> </span><span class="n">circle1</span><span class="p">.</span><span class="n">radius</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">5.0</span><span class="p">;</span>
<span class="w">        </span><span class="n">Circle</span><span class="w"> </span><span class="n">circle2</span><span class="p">;</span><span class="w"> </span><span class="n">circle2</span><span class="p">.</span><span class="n">radius</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">3.5</span><span class="p">;</span>
<span class="w">        </span><span class="n">Rectangle</span><span class="w"> </span><span class="n">rectangle1</span><span class="p">;</span><span class="w"> </span><span class="n">rectangle1</span><span class="p">.</span><span class="n">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">4.0</span><span class="p">;</span><span class="w"> </span><span class="n">rectangle1</span><span class="p">.</span><span class="n">height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">6.0</span><span class="p">;</span>
<span class="w">        </span><span class="n">Rectangle</span><span class="w"> </span><span class="n">rectangle2</span><span class="p">;</span><span class="w"> </span><span class="n">rectangle2</span><span class="p">.</span><span class="n">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2.0</span><span class="p">;</span><span class="w"> </span><span class="n">rectangle2</span><span class="p">.</span><span class="n">height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">8.0</span><span class="p">;</span>

<span class="w">       </span><span class="c1">// Izračunavanje ukupne površine</span>
<span class="w">       </span><span class="kt">double</span><span class="w"> </span><span class="n">totalArea</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span>
<span class="w">       </span><span class="n">totalArea</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">CircleArea</span><span class="p">(</span><span class="n">circle1</span><span class="p">);</span>
<span class="w">       </span><span class="n">totalArea</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">CircleArea</span><span class="p">(</span><span class="n">circle2</span><span class="p">);</span>
<span class="w">       </span><span class="n">totalArea</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">Rectangle1</span><span class="p">(</span><span class="n">rectangle1</span><span class="p">);</span>
<span class="w">       </span><span class="n">totalArea</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">Rectangle2</span><span class="p">(</span><span class="n">rectangle2</span><span class="p">);</span>

<span class="w">       </span><span class="c1">// Ispis ukupne površine</span>
<span class="w">       </span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">$"Total Area of Shapes: {totalArea}"</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Примећујемо да су структуре за представљање круга и правоугаоника
(<code class="docutils literal notranslate"><span class="pre">Circle</span></code> и <code class="docutils literal notranslate"><span class="pre">Rectangle</span></code>) потпуно неповезане и да стога нисмо могли
направити низ облика. Могли бисмо увести наткласу за облик и тако
омогућити креирање низа облика, али наредно решење, као и претходно,
не користи полиморфизам и не може се сматрати написаним у духу ООП.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Program</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">class</span><span class="w"> </span><span class="nc">Shape</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span>

<span class="w">    </span><span class="k">class</span><span class="w"> </span><span class="nc">Circle</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">Shape</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">private</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">radius</span><span class="p">;</span>

<span class="w">        </span><span class="k">public</span><span class="w"> </span><span class="nf">Circle</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">radius</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">this</span><span class="p">.</span><span class="n">radius</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">radius</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">public</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="nf">CircleArea</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">radius</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">radius</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">Math</span><span class="p">.</span><span class="n">PI</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">class</span><span class="w"> </span><span class="nc">Rectangle</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">Shape</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">private</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="p">;</span>

<span class="w">        </span><span class="k">public</span><span class="w"> </span><span class="nf">Rectangle</span><span class="p">(</span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">this</span><span class="p">.</span><span class="n">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">width</span><span class="p">;</span>
<span class="w">            </span><span class="k">this</span><span class="p">.</span><span class="n">height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">height</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">public</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="nf">RectangleArea</span><span class="p">(</span><span class="n">Rectangle</span><span class="w"> </span><span class="n">rectangle</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">width</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">height</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">   </span><span class="p">}</span>


<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">Main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">       </span><span class="c1">// Niz oblika</span>
<span class="w">       </span><span class="n">Shape</span><span class="p">[]</span><span class="w"> </span><span class="n">shapes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Shape</span><span class="p">[]</span>
<span class="w">       </span><span class="p">{</span>
<span class="w">           </span><span class="k">new</span><span class="w"> </span><span class="nf">Circle</span><span class="p">(</span><span class="mf">5.0</span><span class="p">),</span>
<span class="w">           </span><span class="k">new</span><span class="w"> </span><span class="nf">Rectangle</span><span class="p">(</span><span class="mf">4.0</span><span class="p">,</span><span class="w"> </span><span class="mf">6.0</span><span class="p">),</span>
<span class="w">           </span><span class="k">new</span><span class="w"> </span><span class="nf">Circle</span><span class="p">(</span><span class="mf">3.5</span><span class="p">),</span>
<span class="w">           </span><span class="k">new</span><span class="w"> </span><span class="nf">Rectangle</span><span class="p">(</span><span class="mf">2.0</span><span class="p">,</span><span class="w"> </span><span class="mf">8.0</span><span class="p">)</span>
<span class="w">       </span><span class="p">};</span>

<span class="w">       </span><span class="c1">// Izračunavanje ukupne površine</span>
<span class="w">       </span><span class="kt">double</span><span class="w"> </span><span class="n">totalArea</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span>
<span class="w">       </span><span class="k">foreach</span><span class="w"> </span><span class="p">(</span><span class="n">Shape</span><span class="w"> </span><span class="n">shape</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">shapes</span><span class="p">)</span>
<span class="w">           </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">shape</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">Circle</span><span class="p">)</span>
<span class="w">              </span><span class="n">totalArea</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">shape</span><span class="p">.</span><span class="n">CircleArea</span><span class="p">();</span>
<span class="w">           </span><span class="k">else</span><span class="w"> </span><span class="nf">if</span><span class="w"> </span><span class="p">(</span><span class="n">shape</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">Rectangle</span><span class="p">)</span>
<span class="w">              </span><span class="n">totalArea</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">shape</span><span class="p">.</span><span class="n">RectangleArea</span><span class="p">();</span>

<span class="w">       </span><span class="c1">// Ispis ukupne površine</span>
<span class="w">       </span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">$"Total Area of Shapes: {totalArea}"</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Гранање на основу типа је веома проблематично, јер ствара проблеме
приликом проширивања система новим класама. Ако бисмо, на пример,
додали класу за представљање троуглова, у правом ООП решењу заснованом
на полиморфизму не би било потребе да се мења код који израчунава
укупну површину. Са друге стране, у претходном решењу би у том коду
било потребно додати још једну грану којом се обрађују троуглови. Иако
то није проблем у овако кратком програму, у дужим програмима није
тешко замислити да постоје десетине па и стотине места где се обрађују
низови облика, па је измена сваког од њих након додавања нове класе
веома напоран посао, подложан грешкама (компилатор нас неће упозорити
ако случајно на неком месту заборавимо да додамо грану у којој се обрађује
новододата класа).</p>
</section>


    
                <div class="finish-lecture-label" id="finishLectureLabel-8238">Mark activity as completed</div>
                <button type="button" class="finish-lecture-btn not-checked-finish-activity" id="finishLecture-8238" aria-labelledby="MarkLectureComplitedBtn">
                    <img src="/images/check (2) 2@3x.png" alt="Icon for marking the activity as completed">
                </button>
                <div role="button" class="finish-lecture-btn checked-finish-activity d-none" id="checkmark-8238" aria-labelledby="LectureMarkedComplitedBtn">
                    <div class="checked-finish-activity-label">
                        Activity completed!
                    </div>
                    <img src="/images/check (2) 2@3x white.png" alt="Icon indicating the activity is completed">
                </div>
                <div class="lecture-prev-next-toggle">
                    <button type="button" id="prevLecture" class="lecture-toggler-arrows" aria-labelledby="Button to go on previous activity">
                        <span aria-hidden="true">
                            <i class="fas fa-arrow-left fa"></i>
                        </span>
                        <span class="lecture-toggler-arrows-text">Previous activity</span>
                    </button>

                    <button type="button" id="nextLecture" class="lecture-toggler-arrows" aria-labelledby="Button to go on next activity">
                        <span class="lecture-toggler-arrows-text">Next activity</span>
                        <span aria-hidden="true">
                            <i class="fas fa-arrow-right fa"></i>
                        </span>
                    </button>
                </div>
            </div>