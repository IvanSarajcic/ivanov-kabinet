<!DOCTYPE html>
<html lang="sr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Алгебарски типови података - Програмске парадигме</title>
    <link rel="stylesheet" href="../stil.css">
</head>
<body>
<div id="lectureContent-7788" class="lectureContentMaterial active">



    
  <nav style="margin-bottom: 1em;"><a href="../programske_paradigme.html">← Назад на листу лекција</a></nav><section id="id1">
<h1>Алгебарски типови података</h1>
<p>Поред имплементације алгоритама, програмирање подразумева и дефинисање
структура података. У језику Haskell постоји неколико начина да
дефинишемо нове типове података. Ми ћемо се фокусирати на <strong>алгебарске
типове података</strong>, који се дефинишу помоћу кључне речи <code class="docutils literal notranslate"><span class="pre">data</span></code>.</p>
<p>Најједноставнија употреба алгебарских типова је дефинисање набројивих
типова. На пример,</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">Color</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Red</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">Green</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">Blue</span>
</pre></div>
</div>
<p>Овим смо дефинисали тип <code class="docutils literal notranslate"><span class="pre">Color</span></code> и три константе (<code class="docutils literal notranslate"><span class="pre">Red</span></code>, <code class="docutils literal notranslate"><span class="pre">Green</span></code>
и <code class="docutils literal notranslate"><span class="pre">Blue</span></code>) које су овог типа.</p>
<p>Алгебарске типове можемо користити и за дефинисање структурних типова
података (по узору на <code class="docutils literal notranslate"><span class="pre">struct</span></code> у језику C#). На пример,</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">Person</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Person</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">name</span><span class="ow">::</span><span class="kt">String</span><span class="p">,</span><span class="w"> </span><span class="n">yearOfBirth</span><span class="ow">::</span><span class="kt">Int</span><span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
<p>Овим смо дефинисали тип <code class="docutils literal notranslate"><span class="pre">Person</span></code>. Свака особа има име и годину
рођења. Уз тип смо добили и функцију (тзв. конструктор) <code class="docutils literal notranslate"><span class="pre">Person</span></code>,
која прави податак типа <code class="docutils literal notranslate"><span class="pre">Person</span></code> од ниске и броја. На пример,</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Person</span><span class="w"> </span><span class="s">"Petar Petrović"</span><span class="w"> </span><span class="mi">2007</span>
</pre></div>
</div>
<p>је податак типа <code class="docutils literal notranslate"><span class="pre">Person</span></code> (немојте се збунити тиме што смо име типа и
име конструктора означили исто – на то сте навикли и у
објектно–оријентисаним језицима). Имена поља <code class="docutils literal notranslate"><span class="pre">name</span></code> и
<code class="docutils literal notranslate"><span class="pre">yearOfBirth</span></code> се могу користити за јаснију дефиницију података типа
<code class="docutils literal notranslate"><span class="pre">Person</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Person</span><span class="w"> </span><span class="p">{</span><span class="n">name</span><span class="ow">=</span><span class="s">"Petar Petrović"</span><span class="p">,</span><span class="w"> </span><span class="n">yearOfBirth</span><span class="ow">=</span><span class="mi">2007</span><span class="p">}</span>
</pre></div>
</div>
<p>Имена поља су уједно функције које читају одговарајућа поља. На
пример, <code class="docutils literal notranslate"><span class="pre">name</span></code> је функција типа <code class="docutils literal notranslate"><span class="pre">name</span> <span class="pre">::</span> <span class="pre">Person</span> <span class="pre">-&gt;</span> <span class="pre">String</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span><span class="o">&gt;</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="p">(</span><span class="kt">Person</span><span class="w"> </span><span class="s">"Petar Petrović"</span><span class="w"> </span><span class="mi">2007</span><span class="p">)</span>
<span class="s">"Petar Petrović"</span>
</pre></div>
</div>
<p>Имена поља се могу изоставити приликом дефиниције типа:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">Person</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Person</span><span class="w"> </span><span class="kt">String</span><span class="w"> </span><span class="kt">Int</span>
</pre></div>
</div>
<p>Тип може имати и више конструктора. На пример, особа је или запослена
или је студент.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">Person</span><span class="w"> </span><span class="ow">=</span>
<span class="w">   </span><span class="kt">Employee</span><span class="w"> </span><span class="p">{</span><span class="n">name</span><span class="ow">::</span><span class="kt">String</span><span class="p">,</span><span class="w"> </span><span class="n">salary</span><span class="ow">::</span><span class="kt">Double</span><span class="p">}</span>
<span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">Student</span><span class="w"> </span><span class="p">{</span><span class="n">name</span><span class="ow">::</span><span class="kt">String</span><span class="p">,</span><span class="w"> </span><span class="n">int</span><span class="ow">::</span><span class="n">year</span><span class="p">}</span>
</pre></div>
</div>
<p>Дефинисање функција над алгебарским типовима је обично засновано на
уклапању шаблона по разним конструкторима. На пример:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">hello</span> <span class="p">::</span> <span class="n">Person</span> <span class="o">-&gt;</span> <span class="n">String</span>
<span class="n">hello</span> <span class="p">(</span><span class="n">Employee</span> <span class="n">name</span> <span class="n">salary</span><span class="p">)</span> <span class="o">=</span> <span class="s2">"Hello, my name is "</span> <span class="o">++</span> <span class="n">name</span>
<span class="n">hello</span> <span class="p">(</span><span class="n">Student</span> <span class="n">name</span> <span class="n">year</span><span class="p">)</span> <span class="o">=</span> <span class="s2">"Hello, I am "</span> <span class="o">++</span> <span class="n">show</span> <span class="n">year</span> <span class="o">++</span> <span class="s2">". year student"</span>
</pre></div>
</div>
<p>Приметимо да смо за конверзију године у ниску карактера морали
употребити функцију <code class="docutils literal notranslate"><span class="pre">show</span></code>. Ова функција је дефинисана за различите
типове података (све типове који припадају класи типова <code class="docutils literal notranslate"><span class="pre">Show</span></code>) и
служи да се они могу приказати тј. да се податак тог типа претвори у
ниску карактера којом се представља.</p>
<p>Уклапање шаблона може да се врши и у склопу израза <code class="docutils literal notranslate"><span class="pre">case-of</span></code>. На пример:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">personType</span> <span class="p">::</span> <span class="n">Person</span> <span class="o">-&gt;</span> <span class="n">String</span>
<span class="n">personType</span> <span class="n">person</span> <span class="o">=</span> <span class="n">case</span> <span class="n">person</span> <span class="n">of</span>
                      <span class="n">Employee</span> <span class="n">_</span> <span class="n">_</span> <span class="o">-&gt;</span> <span class="s2">"employee"</span>
                      <span class="n">Student</span> <span class="n">_</span> <span class="n">year</span> <span class="o">-&gt;</span> <span class="n">show</span> <span class="n">year</span> <span class="o">++</span> <span class="s2">". year student"</span>
</pre></div>
</div>
<p>Наравно, исто је могло бити урађено на једноставнији начин:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">personType</span> <span class="p">::</span> <span class="n">Person</span> <span class="o">-&gt;</span> <span class="n">String</span>
<span class="n">personType</span> <span class="p">(</span><span class="n">Employee</span> <span class="n">_</span> <span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="s2">"employee"</span>
<span class="n">personType</span> <span class="p">(</span><span class="n">Student</span> <span class="n">_</span> <span class="n">year</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">show</span> <span class="n">year</span> <span class="o">++</span> <span class="s2">". year student"</span>
</pre></div>
</div>
<p>Пуна снага алгебарских типова података види се у случају рекурзивних
(каже се и индуктивних) типова података. Листа је основни пример
таквог типа података. Листа је или празна или се добија надовезивањем
елемента на почетак неке листе (репа). Тип листе целих бројева би се
могао дефинисати на следећи начин:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">data</span> <span class="n">List</span> <span class="o">=</span>
  <span class="n">Empty</span>
<span class="o">|</span> <span class="n">Cons</span> <span class="n">Int</span> <span class="n">List</span>
</pre></div>
</div>
<p>Листа је или празна (конструктор <code class="docutils literal notranslate"><span class="pre">Empty</span></code>) или се добија
надовезивањем броја на листу (конструктор <code class="docutils literal notranslate"><span class="pre">Cons</span></code>). Пример податка
овог типа је</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Cons</span> <span class="mi">1</span> <span class="p">(</span><span class="n">Cons</span> <span class="mi">2</span> <span class="p">(</span><span class="n">Cons</span> <span class="mi">3</span> <span class="n">Empty</span><span class="p">))</span>
</pre></div>
</div>
<p>којим се суштински представља листа <code class="docutils literal notranslate"><span class="pre">[1,</span> <span class="pre">2,</span> <span class="pre">3]</span></code>. Функције које
обрађују индуктивне типове података обично су рекурзивне.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">sum</span> <span class="p">::</span> <span class="n">List</span> <span class="o">-&gt;</span> <span class="n">Int</span>
<span class="nb">sum</span> <span class="n">Empty</span> <span class="o">=</span> <span class="mi">0</span>
<span class="nb">sum</span> <span class="p">(</span><span class="n">Cons</span> <span class="n">x</span> <span class="n">xs</span><span class="p">)</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="nb">sum</span> <span class="n">xs</span>
</pre></div>
</div>
<p>Примећујете велику сличност са рекурзивним функцијама за обраду
уграђених листа (једина разлика је то што се тамо празна листа
обележава са <code class="docutils literal notranslate"><span class="pre">[]</span></code> уместо са <code class="docutils literal notranslate"><span class="pre">Empty</span></code>, а надовезивање са <code class="docutils literal notranslate"><span class="pre">x:xs</span></code>
уместо са <code class="docutils literal notranslate"><span class="pre">Cons</span> <span class="pre">x</span> <span class="pre">xs</span></code>).</p>
<p>У наставку ћемо приказати како је коришћењем индуктивних алгебарских
типова података могуће дефинисати неколико веома корисних структура
података.</p>
<section id="id2">
<h2>Бинарно дрво</h2>
<p>Циљ нам је да направимо структуру података којом можемо да
представљамо скупове елемената тако да ефикасно можемо да убацујемо
нове елементе и да проверавамо да ли елементи припадају скупу. Једна
погодна структура података за представљање скупа је бинарно
дрво. Бинарно дрво је рекурзивна структура података која се састоји од
чворова. У чвору је уписана нека вредност (претпоставићемо,
једноставности ради, да је у питању вредност типа <code class="docutils literal notranslate"><span class="pre">Int</span></code>), а лево и
десно се налазе мања дрвета. Излаз из ове рекурзије представља празно
дрво које нема ни вредност ни наследнике. Тип података за представљање
дрвета може бити дефинисан на следећи начин:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">Tree</span><span class="w"> </span><span class="ow">=</span>
<span class="w">   </span><span class="kt">Empty</span><span class="w"> </span><span class="o">|</span>
<span class="w">   </span><span class="kt">Node</span><span class="w"> </span><span class="kt">Tree</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="kt">Tree</span>
</pre></div>
</div>
<p>Дрво је, дакле, или празно (<code class="docutils literal notranslate"><span class="pre">Empty</span></code>) или је у питању чвор који
садржи три податка: лево поддрво, вредност типа <code class="docutils literal notranslate"><span class="pre">int</span></code> и десно
поддрво.</p>
<p>Сада можемо да формирамо изразе чији је тип <code class="docutils literal notranslate"><span class="pre">Tree</span></code>. На пример</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Node</span><span class="w"> </span><span class="p">(</span><span class="kt">Node</span><span class="w"> </span><span class="kt">Empty</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="kt">Empty</span><span class="p">)</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="p">(</span><span class="kt">Node</span><span class="w"> </span><span class="kt">Empty</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="p">(</span><span class="kt">Node</span><span class="w"> </span><span class="kt">Empty</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="kt">Empty</span><span class="p">))</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="https://petljamediastorage.blob.core.windows.net/root/Media/Default/Kursevi/OnlineNastava/specit4_paradigme_logicko/tree.png" target="_blank"><img alt="https://petljamediastorage.blob.core.windows.net/root/Media/Default/Kursevi/OnlineNastava/specit4_paradigme_logicko/tree.png" class="align-center" src="https://petljamediastorage.blob.core.windows.net/root/Media/Default/Kursevi/OnlineNastava/specit4_paradigme_logicko/tree.png" style="width: 180px;"></a>
<p>Нажалост, приликом њиховог уноса у интерпретатор добићемо поруку да
систем не уме да прикаже дрво. Најједноставнији начин да се то реши је
да се аутоматски генерише функција за приказ дрвета, што се постиже
тиме што се након дефиниције типа дода <code class="docutils literal notranslate"><span class="pre">deriving</span> <span class="pre">Show</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">Tree</span><span class="w"> </span><span class="ow">=</span>
<span class="w">   </span><span class="kt">Empty</span><span class="w"> </span><span class="o">|</span>
<span class="w">   </span><span class="kt">Node</span><span class="w"> </span><span class="kt">Tree</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="kt">Tree</span>
<span class="w">   </span><span class="kr">deriving</span><span class="w"> </span><span class="kt">Show</span>
</pre></div>
</div>
<p>На овај начин је аутоматски дефинисана функција <code class="docutils literal notranslate"><span class="pre">show</span> <span class="pre">::</span> <span class="pre">Tree</span> <span class="pre">-&gt;</span> <span class="pre">String</span></code>
која на основу датог дрвета гради ниску карактера која представља дрво
у истом формату у ком се оно може задати у програму (нпр.
<code class="docutils literal notranslate"><span class="pre">Node</span> <span class="pre">Empty</span> <span class="pre">2</span> <span class="pre">Empty</span></code>).</p>

    <div class="note-wrapper infonote-type">
        <div class="note-icon-holder"> </div>
        <img src="/_runestone/_static/img/infonote-img.svg" class="note-image infonote-image"> 
        <div class="course-content">
            
<p><code class="docutils literal notranslate"><span class="pre">Show</span></code> је заправо класа типова која садржи типове за које постоји
функција <code class="docutils literal notranslate"><span class="pre">show</span></code> која може да претвори податак тог типа у
ниску. Клаузулом <code class="docutils literal notranslate"><span class="pre">deriving</span> <span class="pre">Show</span></code> поред аутоматског генерисања
функције <code class="docutils literal notranslate"><span class="pre">show</span></code> се истовремено наглашава да ће дефинисани тип
података припадати класи <code class="docutils literal notranslate"><span class="pre">show</span></code>. Ми се нећемо детаљније бавити
класама типова. Покушај на интернету да пронађеш више информација о
овој теми.</p>

    </div></div>
<p>Приказани запис дрвета је релативно компликован. Једноставније би било
да, на пример, претходно дрво представимо ниском <code class="docutils literal notranslate"><span class="pre">(.2.)3(.5(.7.))</span></code> и
да дефинишемо функцију <code class="docutils literal notranslate"><span class="pre">parseTree</span></code> која од такве ниске гради дрво.
Употребићемо технику рекурзивног спуста, коју сте срели у првом
разреду. Користимо следећу контекстно-слободну граматику.</p>
<div class="math notranslate nohighlight">
<span class="MathJax_Preview" style="color: inherit;"></span><span class="mjx-chtml MJXc-display" style="text-align: center;"><span id="MathJax-Element-1-Frame" class="mjx-chtml MathJax_CHTML" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;&gt;&lt;mtable columnalign=&quot;right left&quot; rowspacing=&quot;3pt&quot; columnspacing=&quot;0em&quot; displaystyle=&quot;true&quot;&gt;&lt;mtr&gt;&lt;mtd&gt;&lt;mtable columnalign=&quot;right center left&quot; rowspacing=&quot;3pt&quot; columnspacing=&quot;0 thickmathspace&quot; displaystyle=&quot;true&quot;&gt;&lt;mtr&gt;&lt;mtd&gt;&lt;mrow class=&quot;MJX-TeXAtom-ORD&quot;&gt;&lt;mi class=&quot;MJX-tex-mathit&quot; mathvariant=&quot;italic&quot;&gt;d&lt;/mi&gt;&lt;mi class=&quot;MJX-tex-mathit&quot; mathvariant=&quot;italic&quot;&gt;r&lt;/mi&gt;&lt;mi class=&quot;MJX-tex-mathit&quot; mathvariant=&quot;italic&quot;&gt;v&lt;/mi&gt;&lt;mi class=&quot;MJX-tex-mathit&quot; mathvariant=&quot;italic&quot;&gt;o&lt;/mi&gt;&lt;/mrow&gt;&lt;/mtd&gt;&lt;mtd&gt;&lt;mi&gt;&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;&amp;#x2192;&lt;/mo&gt;&lt;/mtd&gt;&lt;mtd&gt;&lt;mo&gt;.&lt;/mo&gt;&lt;/mtd&gt;&lt;/mtr&gt;&lt;mtr&gt;&lt;mtd&gt;&lt;mrow class=&quot;MJX-TeXAtom-ORD&quot;&gt;&lt;mi class=&quot;MJX-tex-mathit&quot; mathvariant=&quot;italic&quot;&gt;d&lt;/mi&gt;&lt;mi class=&quot;MJX-tex-mathit&quot; mathvariant=&quot;italic&quot;&gt;r&lt;/mi&gt;&lt;mi class=&quot;MJX-tex-mathit&quot; mathvariant=&quot;italic&quot;&gt;v&lt;/mi&gt;&lt;mi class=&quot;MJX-tex-mathit&quot; mathvariant=&quot;italic&quot;&gt;o&lt;/mi&gt;&lt;/mrow&gt;&lt;/mtd&gt;&lt;mtd&gt;&lt;mi&gt;&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;&amp;#x2192;&lt;/mo&gt;&lt;/mtd&gt;&lt;mtd&gt;&lt;mo stretchy=&quot;false&quot;&gt;(&lt;/mo&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;v&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mtext&gt;&amp;#xA0;&lt;/mtext&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;mtext&gt;&amp;#xA0;&lt;/mtext&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;v&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;)&lt;/mo&gt;&lt;/mtd&gt;&lt;/mtr&gt;&lt;/mtable&gt;&lt;/mtd&gt;&lt;/mtr&gt;&lt;/mtable&gt;&lt;/math&gt;" role="presentation" style="font-size: 110%; text-align: center; position: relative;"><span id="MJXc-Node-1" class="mjx-math" aria-hidden="true"><span id="MJXc-Node-2" class="mjx-mrow"><span id="MJXc-Node-3" class="mjx-mtable" style="vertical-align: -0.938em; padding: 0px 0.167em;"><span class="mjx-table"><span id="MJXc-Node-4" class="mjx-mtr" style="height: 2.375em;"><span id="MJXc-Node-5" class="mjx-mtd" style="padding: 0px; text-align: right; width: 10.736em;"><span id="MJXc-Node-6" class="mjx-mrow"><span id="MJXc-Node-7" class="mjx-mtable" style="vertical-align: -0.938em; padding: 0px 0.167em;"><span class="mjx-table"><span id="MJXc-Node-8" class="mjx-mtr" style="height: 1.15em;"><span id="MJXc-Node-9" class="mjx-mtd" style="padding: 0px; text-align: right; width: 1.904em;"><span id="MJXc-Node-10" class="mjx-mrow" style="margin-top: -0.2em;"><span id="MJXc-Node-11" class="mjx-texatom"><span id="MJXc-Node-12" class="mjx-mrow"><span id="MJXc-Node-13" class="mjx-mi"><span class="mjx-char MJXc-TeX-main-I" style="padding-top: 0.457em; padding-bottom: 0.287em;">d</span></span><span id="MJXc-Node-14" class="mjx-mi"><span class="mjx-char MJXc-TeX-main-I" style="padding-top: 0.23em; padding-bottom: 0.287em;">r</span></span><span id="MJXc-Node-15" class="mjx-mi"><span class="mjx-char MJXc-TeX-main-I" style="padding-top: 0.23em; padding-bottom: 0.287em;">v</span></span><span id="MJXc-Node-16" class="mjx-mi"><span class="mjx-char MJXc-TeX-main-I" style="padding-top: 0.23em; padding-bottom: 0.287em;">o</span></span></span></span><span class="mjx-strut"></span></span></span><span id="MJXc-Node-17" class="mjx-mtd" style="padding: 0px 0.139em 0px 0px; width: 1.278em;"><span id="MJXc-Node-18" class="mjx-mrow" style="margin-top: -0.2em;"><span id="MJXc-Node-19" class="mjx-mi"></span><span id="MJXc-Node-20" class="mjx-mo MJXc-space3"><span class="mjx-char MJXc-TeX-main-R" style="padding-top: 0.23em; padding-bottom: 0.344em;">→</span></span><span class="mjx-strut"></span></span></span><span id="MJXc-Node-21" class="mjx-mtd" style="padding: 0px 0px 0px 0.139em; text-align: left; width: 6.943em;"><span id="MJXc-Node-22" class="mjx-mrow" style="margin-top: -0.2em;"><span id="MJXc-Node-23" class="mjx-mo"><span class="mjx-char MJXc-TeX-main-R" style="margin-top: -0.168em; padding-bottom: 0.344em;">.</span></span><span class="mjx-strut"></span></span></span></span><span id="MJXc-Node-24" class="mjx-mtr" style="height: 1.225em;"><span id="MJXc-Node-25" class="mjx-mtd" style="padding: 0.15em 0px 0px; text-align: right;"><span id="MJXc-Node-26" class="mjx-mrow" style="margin-top: -0.2em;"><span id="MJXc-Node-27" class="mjx-texatom"><span id="MJXc-Node-28" class="mjx-mrow"><span id="MJXc-Node-29" class="mjx-mi"><span class="mjx-char MJXc-TeX-main-I" style="padding-top: 0.457em; padding-bottom: 0.287em;">d</span></span><span id="MJXc-Node-30" class="mjx-mi"><span class="mjx-char MJXc-TeX-main-I" style="padding-top: 0.23em; padding-bottom: 0.287em;">r</span></span><span id="MJXc-Node-31" class="mjx-mi"><span class="mjx-char MJXc-TeX-main-I" style="padding-top: 0.23em; padding-bottom: 0.287em;">v</span></span><span id="MJXc-Node-32" class="mjx-mi"><span class="mjx-char MJXc-TeX-main-I" style="padding-top: 0.23em; padding-bottom: 0.287em;">o</span></span></span></span><span class="mjx-strut"></span></span></span><span id="MJXc-Node-33" class="mjx-mtd" style="padding: 0.15em 0.139em 0px 0px;"><span id="MJXc-Node-34" class="mjx-mrow" style="margin-top: -0.2em;"><span id="MJXc-Node-35" class="mjx-mi"></span><span id="MJXc-Node-36" class="mjx-mo MJXc-space3"><span class="mjx-char MJXc-TeX-main-R" style="padding-top: 0.23em; padding-bottom: 0.344em;">→</span></span><span class="mjx-strut"></span></span></span><span id="MJXc-Node-37" class="mjx-mtd" style="padding: 0.15em 0px 0px 0.139em; text-align: left;"><span id="MJXc-Node-38" class="mjx-mrow" style="margin-top: -0.2em;"><span id="MJXc-Node-39" class="mjx-mo"><span class="mjx-char MJXc-TeX-main-R" style="padding-top: 0.457em; padding-bottom: 0.571em;">(</span></span><span id="MJXc-Node-40" class="mjx-mi"><span class="mjx-char MJXc-TeX-math-I" style="padding-top: 0.457em; padding-bottom: 0.287em; padding-right: 0.003em;">d</span></span><span id="MJXc-Node-41" class="mjx-mi"><span class="mjx-char MJXc-TeX-math-I" style="padding-top: 0.23em; padding-bottom: 0.287em;">r</span></span><span id="MJXc-Node-42" class="mjx-mi"><span class="mjx-char MJXc-TeX-math-I" style="padding-top: 0.23em; padding-bottom: 0.287em;">v</span></span><span id="MJXc-Node-43" class="mjx-mi"><span class="mjx-char MJXc-TeX-math-I" style="padding-top: 0.23em; padding-bottom: 0.287em;">o</span></span><span id="MJXc-Node-44" class="mjx-mtext"><span class="mjx-char MJXc-TeX-main-R" style="margin-top: -0.281em; padding-bottom: 0.344em;">&nbsp;</span></span><span id="MJXc-Node-45" class="mjx-mi"><span class="mjx-char MJXc-TeX-math-I" style="padding-top: 0.457em; padding-bottom: 0.287em;">b</span></span><span id="MJXc-Node-46" class="mjx-mi"><span class="mjx-char MJXc-TeX-math-I" style="padding-top: 0.23em; padding-bottom: 0.287em;">r</span></span><span id="MJXc-Node-47" class="mjx-mi"><span class="mjx-char MJXc-TeX-math-I" style="padding-top: 0.23em; padding-bottom: 0.287em;">o</span></span><span id="MJXc-Node-48" class="mjx-mi"><span class="mjx-char MJXc-TeX-math-I" style="padding-top: 0.457em; padding-bottom: 0.457em;">j</span></span><span id="MJXc-Node-49" class="mjx-mtext"><span class="mjx-char MJXc-TeX-main-R" style="margin-top: -0.281em; padding-bottom: 0.344em;">&nbsp;</span></span><span id="MJXc-Node-50" class="mjx-mi"><span class="mjx-char MJXc-TeX-math-I" style="padding-top: 0.457em; padding-bottom: 0.287em; padding-right: 0.003em;">d</span></span><span id="MJXc-Node-51" class="mjx-mi"><span class="mjx-char MJXc-TeX-math-I" style="padding-top: 0.23em; padding-bottom: 0.287em;">r</span></span><span id="MJXc-Node-52" class="mjx-mi"><span class="mjx-char MJXc-TeX-math-I" style="padding-top: 0.23em; padding-bottom: 0.287em;">v</span></span><span id="MJXc-Node-53" class="mjx-mi"><span class="mjx-char MJXc-TeX-math-I" style="padding-top: 0.23em; padding-bottom: 0.287em;">o</span></span><span id="MJXc-Node-54" class="mjx-mo"><span class="mjx-char MJXc-TeX-main-R" style="padding-top: 0.457em; padding-bottom: 0.571em;">)</span></span><span class="mjx-strut"></span></span></span></span></span></span><span class="mjx-strut"></span></span></span></span></span></span></span></span><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mtable columnalign="right left" rowspacing="3pt" columnspacing="0em" displaystyle="true"><mtr><mtd><mtable columnalign="right center left" rowspacing="3pt" columnspacing="0 thickmathspace" displaystyle="true"><mtr><mtd><mrow class="MJX-TeXAtom-ORD"><mi class="MJX-tex-mathit" mathvariant="italic">d</mi><mi class="MJX-tex-mathit" mathvariant="italic">r</mi><mi class="MJX-tex-mathit" mathvariant="italic">v</mi><mi class="MJX-tex-mathit" mathvariant="italic">o</mi></mrow></mtd><mtd><mi></mi><mo stretchy="false">→</mo></mtd><mtd><mo>.</mo></mtd></mtr><mtr><mtd><mrow class="MJX-TeXAtom-ORD"><mi class="MJX-tex-mathit" mathvariant="italic">d</mi><mi class="MJX-tex-mathit" mathvariant="italic">r</mi><mi class="MJX-tex-mathit" mathvariant="italic">v</mi><mi class="MJX-tex-mathit" mathvariant="italic">o</mi></mrow></mtd><mtd><mi></mi><mo stretchy="false">→</mo></mtd><mtd><mo stretchy="false">(</mo><mi>d</mi><mi>r</mi><mi>v</mi><mi>o</mi><mtext>&nbsp;</mtext><mi>b</mi><mi>r</mi><mi>o</mi><mi>j</mi><mtext>&nbsp;</mtext><mi>d</mi><mi>r</mi><mi>v</mi><mi>o</mi><mo stretchy="false">)</mo></mtd></mtr></mtable></mtd></mtr></mtable></math></span></span></span><script type="math/tex; mode=display" id="MathJax-Element-1">\begin{split}\begin{eqnarray*}
\mathit{drvo} &\rightarrow& .\\
\mathit{drvo} &\rightarrow& ( drvo\ broj\ drvo )
\end{eqnarray*}\end{split}</script></div>
<p>Пошто су изрази потпуно заграђени, на основу првог карактера
одређујемо да ли се примењује прво или друго правило. У другом правилу
прво треба да прескочимо отворену заграду, затим рекурзивно да
прочитамо лево поддрво, затим да прочитамо број, па да рекурзивно
прочитамо десно поддрво и да на крају прочитамо десну заграду. Сваки
позив функције парсирања треба да прочита садржај са почетка и да
врати прочитано дрво, али и преостали део ниске, иза прочитаног
садржаја. Стога дефинишемо помоћну функцију <code class="docutils literal notranslate"><span class="pre">parseTree'</span></code> која то
ради, док главна функција враћа само дрво, занемаривши преостали
садржај ниске (ако је ниска исправна, преостали садржај ће бити
празан). Наредна имплементација претпоставља да је ниска која се
парсира увек исправно задата.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">import</span><span class="w"> </span><span class="nn">Data.Char</span><span class="w"> </span><span class="p">(</span><span class="nf">isDigit</span><span class="p">)</span>

<span class="nf">parseTree</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">String</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Tree</span>
<span class="nf">parseTree</span><span class="w"> </span><span class="n">str</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">fst</span><span class="w"> </span><span class="p">(</span><span class="n">parseTree'</span><span class="w"> </span><span class="n">str</span><span class="p">)</span>
<span class="w">  </span><span class="kr">where</span>
<span class="w">    </span><span class="n">parseTree'</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">String</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="kt">Tree</span><span class="p">,</span><span class="w"> </span><span class="kt">String</span><span class="p">)</span>
<span class="w">    </span><span class="n">parseTree'</span><span class="w"> </span><span class="n">str</span><span class="w"> </span><span class="ow">=</span>
<span class="w">      </span><span class="kr">if</span><span class="w"> </span><span class="n">head</span><span class="w"> </span><span class="n">str</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sc">'.'</span><span class="w"> </span><span class="kr">then</span>
<span class="w">        </span><span class="p">(</span><span class="kt">Empty</span><span class="p">,</span><span class="w"> </span><span class="n">tail</span><span class="w"> </span><span class="n">str</span><span class="p">)</span>
<span class="w">      </span><span class="kr">else</span>
<span class="w">        </span><span class="kr">let</span><span class="w"> </span><span class="n">str1</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">tail</span><span class="w"> </span><span class="n">str</span><span class="p">;</span><span class="w">                       </span><span class="c1">-- skip (</span>
<span class="w">            </span><span class="p">(</span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="n">str2</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">parseTree'</span><span class="w"> </span><span class="n">str1</span><span class="w">         </span><span class="c1">-- read left subtree</span>
<span class="w">            </span><span class="p">(</span><span class="n">valueStr</span><span class="p">,</span><span class="w"> </span><span class="n">str3</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">span</span><span class="w"> </span><span class="n">isDigit</span><span class="w"> </span><span class="n">str2</span><span class="w">   </span><span class="c1">-- read value</span>
<span class="w">            </span><span class="p">(</span><span class="n">right</span><span class="p">,</span><span class="w"> </span><span class="n">str4</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">parseTree'</span><span class="w"> </span><span class="n">str3</span><span class="w">        </span><span class="c1">-- read right subtree</span>
<span class="w">            </span><span class="n">str5</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">tail</span><span class="w"> </span><span class="n">str4</span><span class="w">                       </span><span class="c1">-- skip )</span>
<span class="w">        </span><span class="kr">in</span><span class="w"> </span><span class="p">(</span><span class="kt">Node</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="p">(</span><span class="n">read</span><span class="w"> </span><span class="n">valueStr</span><span class="p">)</span><span class="w"> </span><span class="n">right</span><span class="p">,</span><span class="w"> </span><span class="n">str5</span><span class="p">)</span>
</pre></div>
</div>
<p>Обратимо пажњу на примену функције <code class="docutils literal notranslate"><span class="pre">span</span> <span class="pre">isDigit</span></code>. Функција
<code class="docutils literal notranslate"><span class="pre">isDigit</span> <span class="pre">::</span> <span class="pre">Char</span> <span class="pre">-&gt;</span> <span class="pre">Bool</span></code> је увезена из библиотеке <code class="docutils literal notranslate"><span class="pre">Data.Char</span></code>
(зато је на почетку програма морала бити наведена декларација
<code class="docutils literal notranslate"><span class="pre">import</span></code>) и проверава да ли је дати карактер цифра. Функција
<code class="docutils literal notranslate"><span class="pre">span</span> <span class="pre">::</span> <span class="pre">(a</span> <span class="pre">-&gt;</span> <span class="pre">Bool)</span> <span class="pre">-&gt;</span> <span class="pre">[a]</span> <span class="pre">-&gt;</span> <span class="pre">([a],</span> <span class="pre">[a])</span></code> дели листу на два дела:
елементе са почетка листе који задовољавају услов дат као аргумент
функције <code class="docutils literal notranslate"><span class="pre">span</span></code> и остатак листе. Функција <code class="docutils literal notranslate"><span class="pre">read</span></code> чита бројевну
вредност из ниске која представља исправан запис броја.</p>
<p>За представљање скупа ми ћемо користити уређена тј. претраживачка
дрвета (енг. <em>binary search tree</em>). Њихова основна особина је да сваки
чвор задовољава да се у левом поддрвету налазе вредности које су мање
или једнаке од вредности у том чвору, а у десном поддрвету вредности
које су веће или једнаке од вредности у том чвору. Ако не желимо
дупликате (а скуп обично не садржи дупликате), онда захтевамо да важе
стриктне неједнакости (лево су строго мањи, а десно строго већи
елементи од оног уписаног у чвору). На основу овога можемо дефинисати
рекурзивну функцију за уметање елемента у дрво. Она прима дрво и
вредност која се умеће и враћа ново дрво. Приметимо да се већи део
полазног дрвета задржава, тако да овај приступ није меморијски превише
захтеван (пошто се у функционалном програмирању обично не врши
модификација података, они могу бити дељени, без копирања).</p>
<p>Уметање вредности у право дрво даје дрво коме је та вредност у корену,
а лево и десно су празна поддрвета.  Уметање у непразно дрво
подразумева поређење вредности <code class="docutils literal notranslate"><span class="pre">x</span></code>, која се умеће, са вредношћу
уписаном у корен дрвета.  Ако је <code class="docutils literal notranslate"><span class="pre">x</span></code> мање од корена, врши се
рекурзивно убацивање у лево поддрво (вредност у корену и десно поддрво
остају неизмењени); ако је веће врши се рекурзивно убацивање у десно
поддрво (вредност у корену и лево поддрво остају неизмењени), а ако је
једнако вредности у корену, онда се цело дрво враћа неизмењено (не
желимо да убацујемо дупликате).</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">insert</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Tree</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Tree</span>
<span class="nf">insert</span><span class="w"> </span><span class="kt">Empty</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Node</span><span class="w"> </span><span class="kt">Empty</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="kt">Empty</span>
<span class="nf">insert</span><span class="w"> </span><span class="p">(</span><span class="kt">Node</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="n">root</span><span class="w"> </span><span class="n">right</span><span class="p">)</span><span class="w"> </span><span class="n">x</span>
<span class="w">   </span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">root</span><span class="w">  </span><span class="ow">=</span><span class="w">  </span><span class="kt">Node</span><span class="w"> </span><span class="p">(</span><span class="n">insert</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="n">root</span><span class="w"> </span><span class="n">right</span>
<span class="w">   </span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">root</span><span class="w">  </span><span class="ow">=</span><span class="w">  </span><span class="kt">Node</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="n">root</span><span class="w"> </span><span class="p">(</span><span class="n">insert</span><span class="w"> </span><span class="n">right</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="w">   </span><span class="o">|</span><span class="w"> </span><span class="n">otherwise</span><span class="w"> </span><span class="ow">=</span><span class="w">  </span><span class="kt">Node</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="n">root</span><span class="w"> </span><span class="n">right</span>
</pre></div>
</div>
<p>Понављањем ове функције лако можемо да формирамо дрво од листе
бројева. Тај поступак можемо имплементирати кроз функцију која формира
дрво од елемената листе.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">treeOfList</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="kt">Int</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Tree</span>
<span class="nf">treeOfList</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">foldl</span><span class="w"> </span><span class="n">insert</span><span class="w"> </span><span class="kt">Empty</span>
</pre></div>
</div>
<p>Сложеност функције <code class="docutils literal notranslate"><span class="pre">insert</span></code> и <code class="docutils literal notranslate"><span class="pre">treeOfList</span></code> зависи од распореда
чворова дрвета. У најгорем случају, када је листа од које се формира
дрво сортирана, сви чворови ће завршити на једној страни (увек ће лево
или ће увек десно поддрво бити празно, у зависности од тога како је
листа сортирана). Тада је сложеност функције <code class="docutils literal notranslate"><span class="pre">insert</span></code> линеарна, а
функције <code class="docutils literal notranslate"><span class="pre">treeOfList</span></code> квадратна. Ипак, ако су елементи који се
убацују у дрво насумични, можемо очекивати да ће дрво бити прилично
балансирано (да ће број чворова са леве и са десне стране сваког чвора
бити отприлике једнак) и тада ће висина дрвета логаритамски зависити
од броја чворова дрвета, па ће сложеност функције <code class="docutils literal notranslate"><span class="pre">insert</span></code> бити
<span class="math notranslate nohighlight"><span class="MathJax_Preview" style="color: inherit;"></span><span id="MathJax-Element-2-Frame" class="mjx-chtml MathJax_CHTML" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;(&lt;/mo&gt;&lt;mi&gt;log&lt;/mi&gt;&lt;mo&gt;&amp;#x2061;&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;)&lt;/mo&gt;&lt;/math&gt;" role="presentation" style="font-size: 110%; position: relative;"><span id="MJXc-Node-55" class="mjx-math" aria-hidden="true"><span id="MJXc-Node-56" class="mjx-mrow"><span id="MJXc-Node-57" class="mjx-mi"><span class="mjx-char MJXc-TeX-math-I" style="padding-top: 0.457em; padding-bottom: 0.287em;">O</span></span><span id="MJXc-Node-58" class="mjx-mo"><span class="mjx-char MJXc-TeX-main-R" style="padding-top: 0.457em; padding-bottom: 0.571em;">(</span></span><span id="MJXc-Node-59" class="mjx-mi"><span class="mjx-char MJXc-TeX-main-R" style="padding-top: 0.401em; padding-bottom: 0.571em;">log</span></span><span id="MJXc-Node-60" class="mjx-mo"><span class="mjx-char"></span></span><span id="MJXc-Node-61" class="mjx-mi MJXc-space1"><span class="mjx-char MJXc-TeX-math-I" style="padding-top: 0.23em; padding-bottom: 0.287em;">n</span></span><span id="MJXc-Node-62" class="mjx-mo"><span class="mjx-char MJXc-TeX-main-R" style="padding-top: 0.457em; padding-bottom: 0.571em;">)</span></span></span></span><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></math></span></span><script type="math/tex" id="MathJax-Element-2">O(\log n)</script></span>, а сложеност функције <code class="docutils literal notranslate"><span class="pre">treeOfList</span></code> бити <span class="math notranslate nohighlight"><span class="MathJax_Preview" style="color: inherit;"></span><span id="MathJax-Element-3-Frame" class="mjx-chtml MathJax_CHTML" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;log&lt;/mi&gt;&lt;mo&gt;&amp;#x2061;&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;)&lt;/mo&gt;&lt;/math&gt;" role="presentation" style="font-size: 110%; position: relative;"><span id="MJXc-Node-63" class="mjx-math" aria-hidden="true"><span id="MJXc-Node-64" class="mjx-mrow"><span id="MJXc-Node-65" class="mjx-mi"><span class="mjx-char MJXc-TeX-math-I" style="padding-top: 0.457em; padding-bottom: 0.287em;">O</span></span><span id="MJXc-Node-66" class="mjx-mo"><span class="mjx-char MJXc-TeX-main-R" style="padding-top: 0.457em; padding-bottom: 0.571em;">(</span></span><span id="MJXc-Node-67" class="mjx-mi"><span class="mjx-char MJXc-TeX-math-I" style="padding-top: 0.23em; padding-bottom: 0.287em;">n</span></span><span id="MJXc-Node-68" class="mjx-mi MJXc-space1"><span class="mjx-char MJXc-TeX-main-R" style="padding-top: 0.401em; padding-bottom: 0.571em;">log</span></span><span id="MJXc-Node-69" class="mjx-mo"><span class="mjx-char"></span></span><span id="MJXc-Node-70" class="mjx-mi MJXc-space1"><span class="mjx-char MJXc-TeX-math-I" style="padding-top: 0.23em; padding-bottom: 0.287em;">n</span></span><span id="MJXc-Node-71" class="mjx-mo"><span class="mjx-char MJXc-TeX-main-R" style="padding-top: 0.457em; padding-bottom: 0.571em;">)</span></span></span></span><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></math></span></span><script type="math/tex" id="MathJax-Element-3">O(n
\log n)</script></span>.</p>

    <div class="note-wrapper infonote-type">
        <div class="note-icon-holder"> </div>
        <img src="/_runestone/_static/img/infonote-img.svg" class="note-image infonote-image"> 
        <div class="course-content">
            
<p>Уместо обичних претраживачких дрвета могуће је користити и
тзв. самобалансирајућа дрвета. Најпознатије врсте таквих дрвета су
<strong>АВЛ</strong> дрвета и <strong>Црвено-црна дрвета</strong>. Алгоритам уметања у ова
дрвета је такав да се приликом уметања проверава да ли је нарушена
равнотежа између левог и десног дела и ако јесте, дрво се ротира
тако да би се та равнотежа поново успоставила.</p>

    </div></div>
<p>Када је формирано дрво, тада можемо вршити његову претрагу, тј. можемо
имплементирати функцију која проверава да ли дрво садржи дати елемент.
Празно дрво не садржи ниједан елемент. Непразно дрво претражујемо тако
што елемент који тражимо поредимо са вредношћу у корену. Ако је
вредност мања од корена, тражимо је рекурзивно у левом поддрвету, ако
је већа, у десном, а ако је једнака вредности у корену, онда знамо да
дрво садржи тражену вредност.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">contains</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Tree</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Bool</span>
<span class="nf">contains</span><span class="w"> </span><span class="kt">Empty</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">False</span>
<span class="nf">contains</span><span class="w"> </span><span class="p">(</span><span class="kt">Node</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="n">root</span><span class="w"> </span><span class="n">right</span><span class="p">)</span><span class="w"> </span><span class="n">x</span>
<span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">root</span><span class="w">    </span><span class="ow">=</span><span class="w"> </span><span class="n">contains</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="n">x</span>
<span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">root</span><span class="w">    </span><span class="ow">=</span><span class="w"> </span><span class="n">contains</span><span class="w"> </span><span class="n">right</span><span class="w"> </span><span class="n">x</span>
<span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="n">otherwise</span><span class="w">   </span><span class="ow">=</span><span class="w"> </span><span class="kt">True</span>
</pre></div>
</div>

    <div class="note-wrapper infonote-type">
        <div class="note-icon-holder"> </div>
        <img src="/_runestone/_static/img/infonote-img.svg" class="note-image infonote-image"> 
        <div class="course-content">
            
<p>Ово је вероватно добар тренутак да упоредимо приказано решење у
језику Haskell са решењем у традиционалном императивном програмском
језику, какав је C.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">Node</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="p">;</span>
<span class="w">   </span><span class="k">struct</span><span class="w"> </span><span class="nc">Node</span><span class="w"> </span><span class="o">*</span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">right</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="nf">newNode</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">Node</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Node</span><span class="p">));</span>
<span class="w">      </span><span class="n">new</span><span class="o">-&gt;</span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value</span><span class="p">;</span>
<span class="w">      </span><span class="n">new</span><span class="o">-&gt;</span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="o">-&gt;</span><span class="n">rigth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">freeNode</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">node</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">node</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">freeNode</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
<span class="w">      </span><span class="n">freeNode</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
<span class="w">      </span><span class="n">free</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
<span class="w">   </span><span class="p">}</span>
<span class="p">}</span>

<span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="nf">insert</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">root</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">root</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">newNode</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">value</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">root</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">)</span>
<span class="w">      </span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">insert</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">);</span>
<span class="w">   </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">value</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">root</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">)</span>
<span class="w">      </span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">insert</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">);</span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="n">root</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">contains</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">root</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">root</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">value</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">root</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">)</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">contains</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">);</span>
<span class="w">   </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">value</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">root</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">)</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">contains</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">);</span>
<span class="w">   </span><span class="k">else</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="nf">treeOfArray</span><span class="p">(</span><span class="kt">int</span><span class="p">[]</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">root</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">       </span><span class="n">root</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">insert</span><span class="p">(</span><span class="n">root</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">root</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">printTree</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">root</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">root</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">       </span><span class="n">printTree</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span>
<span class="w">       </span><span class="n">printf</span><span class="p">(</span><span class="s">"%d "</span><span class="p">,</span><span class="w"> </span><span class="n">root</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">);</span>
<span class="w">       </span><span class="n">printTree</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
<span class="w">   </span><span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">};</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="w">    </span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">root</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">treeOfArray</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">);</span>
<span class="w">    </span><span class="n">printTree</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
<span class="w">    </span><span class="n">freeNode</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Примећујемо да су алгоритми који се користе исти као у
одговарајућим Hakell функцијама, али да је кôд оптерећен многим
техничким детаљима о којима није било потребе водити рачуна у
Haskell имплементацији. На пример, у језику C је било потребно
ручно алоцирати и ослобађати меморију (коришћењем библиотечких
функција <code class="docutils literal notranslate"><span class="pre">malloc</span></code> и <code class="docutils literal notranslate"><span class="pre">free</span></code>). Употреба показивача је
експлицитна, што на многим местима чини да је кôд оптерећен
додатним симболима (попут <code class="docutils literal notranslate"><span class="pre">*</span></code>, <code class="docutils literal notranslate"><span class="pre">-&gt;</span></code>) и програм је теже и писати
и разумети. Захваљујући библиотечкој функцији <code class="docutils literal notranslate"><span class="pre">fold</span></code>,
имплементација креирања дрвета од листе је много краћа и
једноставнија од имплементације у C-у која мора да користи петљу и
да ручно имплементира функционалност коју нам пружа <code class="docutils literal notranslate"><span class="pre">fold</span></code>.</p>

    </div></div>
<p>У уређеном дрвету је лако пронаћи минимални и максимални елемент (они
се налазе у крајњем левом и крајњем десном чвору).</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">minTree</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Tree</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span>
<span class="nf">minTree</span><span class="w"> </span><span class="p">(</span><span class="kt">Node</span><span class="w"> </span><span class="kt">Empty</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="kr">_</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span>
<span class="nf">minTree</span><span class="w"> </span><span class="p">(</span><span class="kt">Node</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">minTree</span><span class="w"> </span><span class="n">left</span>
</pre></div>
</div>
<p>Дефинишимо и функцију која уклања тај најмањи елемент дрвета (под
претпоставком да је дрво непразно). Функција враћа уређени пар, који
се састоји од уклоњене вредности и измењеног дрвета. Ако не постоји
лево поддрво корен дрвета је најмањи елемент, а његовим брисањем
остаје само десно поддрво. У супротном бришемо најмањи елемент левог
поддрвета.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">deleteMin</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Tree</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="kt">Int</span><span class="p">,</span><span class="w"> </span><span class="kt">Tree</span><span class="p">)</span>
<span class="nf">deleteMin</span><span class="w"> </span><span class="p">(</span><span class="kt">Node</span><span class="w"> </span><span class="kt">Empty</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">right</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">right</span><span class="p">)</span>
<span class="nf">deleteMin</span><span class="w"> </span><span class="p">(</span><span class="kt">Node</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">right</span><span class="p">)</span><span class="w">  </span><span class="ow">=</span><span class="w"> </span><span class="kr">let</span><span class="w"> </span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">left'</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">deleteMin</span><span class="w"> </span><span class="n">left</span>
<span class="w">                                  </span><span class="kr">in</span><span class="w"> </span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="kt">Node</span><span class="w"> </span><span class="n">left'</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">right</span><span class="p">)</span>
</pre></div>
</div>
<p>Ова се функција може искористити и за уклањање дате вредности из скупа
(тј. дрвета). Брисањем било чега из празног дрвета дрво остаје празно.
Ако је дрво непразно, а вредност која се брише мања од корена,
рекурзивно се та вредност брише из левог поддрвета. Ако је вредност
већа од корена, рекурзивно се та вредност брише из десног поддрвета.
Најкомпликованији је случај када је вредност која се брише једнака
вредности у корену. Ако је тада десно поддрво празно, можемо само
вратити лево поддрво. У супротном можемо обрисати најмању вредност из
десног поддрвета и њу ставити на место корена (аналогно бисмо могли
обрисати највећу вредност из левог поддрвета и њу ставити на место
корена). Да бисмо анализирали да ли је десно поддрво празно или
непразно, можемо употребити израз <code class="docutils literal notranslate"><span class="pre">case-of</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">delete</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Tree</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Tree</span>
<span class="nf">delete</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="kt">Empty</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Empty</span>
<span class="nf">delete</span><span class="w"> </span><span class="n">x'</span><span class="w"> </span><span class="p">(</span><span class="kt">Node</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">right</span><span class="p">)</span>
<span class="w">   </span><span class="o">|</span><span class="w"> </span><span class="n">x'</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">x</span><span class="w">      </span><span class="ow">=</span><span class="w"> </span><span class="kt">Node</span><span class="w"> </span><span class="p">(</span><span class="n">delete</span><span class="w"> </span><span class="n">x'</span><span class="w"> </span><span class="n">left</span><span class="p">)</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">right</span>
<span class="w">   </span><span class="o">|</span><span class="w"> </span><span class="n">x'</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">x</span><span class="w">      </span><span class="ow">=</span><span class="w"> </span><span class="kt">Node</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">(</span><span class="n">delete</span><span class="w"> </span><span class="n">x'</span><span class="w"> </span><span class="n">right</span><span class="p">)</span>
<span class="w">   </span><span class="o">|</span><span class="w"> </span><span class="n">otherwise</span><span class="w">   </span><span class="ow">=</span><span class="w"> </span><span class="kr">case</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="kr">of</span><span class="w"> </span><span class="kt">Empty</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">left</span>
<span class="w">                             </span><span class="kr">_</span><span class="w">     </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kr">let</span><span class="w"> </span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">right'</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">deleteMin</span><span class="w"> </span><span class="n">right</span>
<span class="w">                                       </span><span class="kr">in</span><span class="w"> </span><span class="kt">Node</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">right'</span>
</pre></div>
</div>
<p>Од елемената дрвета можемо формирати листу. Ако прво покупимо елементе
из левог поддрвета, затим корен, па затим елементе из десног
поддрвета, захваљујући уређености дрвета добијена листа ће бити
сортирана. На тај начин добијамо још један алгоритам сортирања
(енг. <em>tree sort</em>).</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">listOfTree</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Tree</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="kt">Int</span><span class="p">]</span>
<span class="nf">listOfTree</span><span class="w"> </span><span class="kt">Empty</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">[]</span>
<span class="nf">listOfTree</span><span class="w"> </span><span class="p">(</span><span class="kt">Node</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="n">root</span><span class="w"> </span><span class="n">right</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span>
<span class="w">   </span><span class="n">listOfTree</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="p">[</span><span class="n">root</span><span class="p">]</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">listOfTree</span><span class="w"> </span><span class="n">right</span>

<span class="nf">treeSort</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="kt">Int</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="kt">Int</span><span class="p">]</span>
<span class="w">   </span><span class="n">treeSort</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">listOfTree</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">treeOfList</span>
</pre></div>
</div>
<p>У дрвету које смо дефинисали налазе се увек подаци типа <code class="docutils literal notranslate"><span class="pre">Int</span></code>,
међутим, јасно је да би се на исти начин могли чувати и подаци других
типова. Могуће је дефинисати и дрво којем је тип података записаних у
чвору параметар (навикли сте на овакве „генеричке“ типове у језику C#
где сте користили типове попут <code class="docutils literal notranslate"><span class="pre">List&lt;int&gt;</span></code> где је тип елемената
колекције задат као параметарски тип те колекције).</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">Tree</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span>
<span class="w">   </span><span class="kt">Empty</span>
<span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">Node</span><span class="w"> </span><span class="p">(</span><span class="kt">Tree</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">(</span><span class="kt">Tree</span><span class="w"> </span><span class="n">a</span><span class="p">)</span>
<span class="kr">deriving</span><span class="w"> </span><span class="kt">Show</span>
</pre></div>
</div>
<p>У овом случају тип означен са <code class="docutils literal notranslate"><span class="pre">a</span></code> је параметар типа дрво. Дрво
садржи лево и десно поддрво (која такође имају елементе типа <code class="docutils literal notranslate"><span class="pre">a</span></code>) и
вредност типа <code class="docutils literal notranslate"><span class="pre">a</span></code>.</p>
<p>Да бисмо могли формирати претраживачко дрво, тип <code class="docutils literal notranslate"><span class="pre">a</span></code> мора да подржи
поређење елемената, тј. мора бити класе <code class="docutils literal notranslate"><span class="pre">Ord</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">insert</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Ord</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Tree</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Tree</span><span class="w"> </span><span class="n">a</span>
<span class="nf">insert</span><span class="w"> </span><span class="kt">Empty</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Node</span><span class="w"> </span><span class="kt">Empty</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="kt">Empty</span>
<span class="nf">insert</span><span class="w"> </span><span class="p">(</span><span class="kt">Node</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="n">root</span><span class="w"> </span><span class="n">right</span><span class="p">)</span><span class="w"> </span><span class="n">x</span>
<span class="w">   </span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">root</span><span class="w">  </span><span class="ow">=</span><span class="w">  </span><span class="kt">Node</span><span class="w"> </span><span class="p">(</span><span class="n">insert</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="n">root</span><span class="w"> </span><span class="n">right</span>
<span class="w">   </span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">root</span><span class="w">  </span><span class="ow">=</span><span class="w">  </span><span class="kt">Node</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="n">root</span><span class="w"> </span><span class="p">(</span><span class="n">insert</span><span class="w"> </span><span class="n">right</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="w">   </span><span class="o">|</span><span class="w"> </span><span class="n">otherwise</span><span class="w"> </span><span class="ow">=</span><span class="w">  </span><span class="kt">Node</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="n">root</span><span class="w"> </span><span class="n">right</span>
</pre></div>
</div>
</section>
<section id="id3">
<h2>Ред</h2>
<p>Листа једноставно може да се користи као стек. Елементи могу да се
додају са почетка и скидају са почетка листе у линеарној сложености.
Међутим, ред је мало компликованије имплементирати (наравно, постоје
библиотечке имплементације, али ћемо га овде, вежбе ради,
имплементирати ручно).</p>
<p>Додавање елемената на крај листе има линеарну сложеност, па ред није
добро имплементирати помоћу листе. Уобичајени начин имплементације
реда у функционалним језицима је тзв. <strong>амортизовани ред</strong>
(енг. <em>amortized queue</em>) који се састоји од две листе.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">Queue</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Queue</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span>
</pre></div>
</div>
<p>У празном реду су обе листе празне.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">emptyQueue</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Queue</span><span class="w"> </span><span class="n">a</span>
<span class="nf">emptyQueue</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Queue</span><span class="w"> </span><span class="kt">[]</span><span class="w"> </span><span class="kt">[]</span>
</pre></div>
</div>
<p>Елементи се увек додају на почетак прве листе, а скидају са почетка друге.</p>
<p>Операцију додавања елемента у ред је тривијално имплементирати.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">push</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Queue</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Queue</span><span class="w"> </span><span class="n">a</span>
<span class="nf">push</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">(</span><span class="kt">Queue</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="n">right</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Queue</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="n">left</span><span class="p">)</span><span class="w"> </span><span class="n">right</span>
</pre></div>
</div>
<p>Уклањање елемента из реда је мало компликованије. Функцију ћемо
дефинисати тако да врати уклоњени елемент и нови ред. Пошто уклањање
из празног реда није могуће, потребно је да се некако у повратној
вредности укључи и могућност да је враћена вредност са почетка реда,
али и да уклањање није успело. Програмски језици углавном ово решавају
тако што типове проширују специјалном вредношћу <code class="docutils literal notranslate"><span class="pre">null</span></code> која означава
да операција није успешно извршена. У функционалним језицима се обично
користи посебан тип <code class="docutils literal notranslate"><span class="pre">Maybe</span></code> који омоћава разликовање исправних и
недостајућих вредности.</p>

    <div class="note-wrapper infonote-type">
        <div class="note-icon-holder"> </div>
        <img src="/_runestone/_static/img/infonote-img.svg" class="note-image infonote-image"> 
        <div class="course-content">
            
<p>Тип <code class="docutils literal notranslate"><span class="pre">Maybe</span> <span class="pre">a</span></code> омогућава представљање <strong>опционих вредности</strong> типа
<code class="docutils literal notranslate"><span class="pre">a</span></code>. Конструктор <code class="docutils literal notranslate"><span class="pre">Nothing</span></code> означава недостајућу вредност, а
<code class="docutils literal notranslate"><span class="pre">Just</span></code> нормалну вредност. На пример, <code class="docutils literal notranslate"><span class="pre">Just</span> <span class="pre">3</span></code> је податак типа
<code class="docutils literal notranslate"><span class="pre">Maybe</span> <span class="pre">Int</span></code>. Овај тип се често користи да означи повратне
вредности функција које из неког разлога некада не могу да врате
исправну вредност.  На пример, ако функција успе и треба да врати
вредност <code class="docutils literal notranslate"><span class="pre">3</span></code>, она ће вратити вредност <code class="docutils literal notranslate"><span class="pre">Just</span> <span class="pre">3</span></code>, а ако не успе,
вратиће вредност <code class="docutils literal notranslate"><span class="pre">Nothing</span></code> (ово одговара вредности <code class="docutils literal notranslate"><span class="pre">null</span></code> у
програмском језику C#, која служи да означи недостатак исправне
вредности).</p>
<p>Предност коришћења посебног у односу на специјалну вредност
<code class="docutils literal notranslate"><span class="pre">null</span></code> је то што је једини начин да се до исправне вредности дође
тај да се експлицитно испита да ли је вредност исправна. Ово се
обично имплементира или поклапањем шаблона или изразом <code class="docutils literal notranslate"><span class="pre">case</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">g</span> <span class="n">x</span> <span class="o">=</span> <span class="n">case</span> <span class="n">f</span> <span class="n">x</span> <span class="n">of</span>
         <span class="n">Nothing</span> <span class="o">-&gt;</span> <span class="o">-</span><span class="mi">1</span>
         <span class="n">Just</span> <span class="n">value</span> <span class="o">-&gt;</span> <span class="n">value</span>
</pre></div>
</div>

    </div></div>
<p>Пошто није могуће скидање вредности из празног реда, Уместо да
функција <code class="docutils literal notranslate"><span class="pre">pop</span></code> враћа пар типа <code class="docutils literal notranslate"><span class="pre">(a,</span> <span class="pre">Queue</span> <span class="pre">a)</span></code>, она ће враћати пар
типа <code class="docutils literal notranslate"><span class="pre">(Maybe</span> <span class="pre">a,</span> <span class="pre">Queue</span> <span class="pre">a)</span></code>.</p>
<p>Aко је цео ред празан, наша функција <code class="docutils literal notranslate"><span class="pre">pop</span></code> враћа <code class="docutils literal notranslate"><span class="pre">Nothing</span></code> и
празан ред. Ако десна листа није празна, враћамо њен први елемент
(упакован у конструктор <code class="docutils literal notranslate"><span class="pre">Just</span></code>), док ред мењамо тако да му лева
листа остаје неизмењена, а десна скраћена за њен почетни елемент. Ако
је само десна листа празна, тада обрћемо леву листу и пребацујемо је
на десну страну и затим уклањамо први елемент тако добијене листе.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">pop</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Queue</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="kt">Maybe</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">Queue</span><span class="w"> </span><span class="n">a</span><span class="p">)</span>
<span class="nf">pop</span><span class="w"> </span><span class="p">(</span><span class="kt">Queue</span><span class="w"> </span><span class="kt">[]</span><span class="w"> </span><span class="kt">[]</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="kt">Nothing</span><span class="p">,</span><span class="w"> </span><span class="kt">Queue</span><span class="w"> </span><span class="kt">[]</span><span class="w"> </span><span class="kt">[]</span><span class="p">)</span>
<span class="nf">pop</span><span class="w"> </span><span class="p">(</span><span class="kt">Queue</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">))</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="kt">Just</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">Queue</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="n">xs</span><span class="p">)</span>
<span class="nf">pop</span><span class="w"> </span><span class="p">(</span><span class="kt">Queue</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="kt">[]</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">let</span><span class="w"> </span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">reverse</span><span class="w"> </span><span class="n">left</span>
<span class="w">                       </span><span class="kr">in</span><span class="w"> </span><span class="p">(</span><span class="kt">Just</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">Queue</span><span class="w"> </span><span class="kt">[]</span><span class="w"> </span><span class="n">xs</span><span class="p">)</span>
</pre></div>
</div>
<p>Сложеност најгорег случаја операције <code class="docutils literal notranslate"><span class="pre">pop</span></code> је линеарна, јер је
функција <code class="docutils literal notranslate"><span class="pre">reverse</span></code> линеарне сложености. Ипак, након једног
пребацивања елемената са леве на десну страну, много наредних
операција <code class="docutils literal notranslate"><span class="pre">pop</span></code> ће бити могуће извршити веома брзо. Ако анализирамо
пут сваког елемента кроз ред, видимо да ће он једном бити додат на
почетак леве листе, једном бити склоњен са почетка леве и додат на
почетак десне листе (ово се догађа током извршавања функције
<code class="docutils literal notranslate"><span class="pre">reverse</span></code>) и на крају једном скинут са десне листе. Дакле, сваки
елемент учествује у тачно четири операције константне сложености, па
се <span class="math notranslate nohighlight"><span class="MathJax_Preview" style="color: inherit;"></span><span id="MathJax-Element-4-Frame" class="mjx-chtml MathJax_CHTML" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/math&gt;" role="presentation" style="font-size: 110%; position: relative;"><span id="MJXc-Node-72" class="mjx-math" aria-hidden="true"><span id="MJXc-Node-73" class="mjx-mrow"><span id="MJXc-Node-74" class="mjx-mi"><span class="mjx-char MJXc-TeX-math-I" style="padding-top: 0.23em; padding-bottom: 0.287em;">n</span></span></span></span><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi></math></span></span><script type="math/tex" id="MathJax-Element-4">n</script></span> елемената реда може обрадити у сложености <span class="math notranslate nohighlight"><span class="MathJax_Preview" style="color: inherit;"></span><span id="MathJax-Element-5-Frame" class="mjx-chtml MathJax_CHTML" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;)&lt;/mo&gt;&lt;/math&gt;" role="presentation" style="font-size: 110%; position: relative;"><span id="MJXc-Node-75" class="mjx-math" aria-hidden="true"><span id="MJXc-Node-76" class="mjx-mrow"><span id="MJXc-Node-77" class="mjx-mi"><span class="mjx-char MJXc-TeX-math-I" style="padding-top: 0.457em; padding-bottom: 0.287em;">O</span></span><span id="MJXc-Node-78" class="mjx-mo"><span class="mjx-char MJXc-TeX-main-R" style="padding-top: 0.457em; padding-bottom: 0.571em;">(</span></span><span id="MJXc-Node-79" class="mjx-mi"><span class="mjx-char MJXc-TeX-math-I" style="padding-top: 0.23em; padding-bottom: 0.287em;">n</span></span><span id="MJXc-Node-80" class="mjx-mo"><span class="mjx-char MJXc-TeX-main-R" style="padding-top: 0.457em; padding-bottom: 0.571em;">)</span></span></span></span><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></math></span></span><script type="math/tex" id="MathJax-Element-5">O(n)</script></span>,
што значи да операције додавања и уклањања елемената имају константну
амортизовану сложеност.</p>
<p>Да бисмо могли да експериментишемо са овом структуром података,
пожељно је да можемо да је испишемо. Аутоматски генерисана функција
исписа (коју можемо добити ако након дефиниције типа ставимо
<code class="docutils literal notranslate"><span class="pre">deriving</span> <span class="pre">Show</span></code>) приказује интерну репрезентацију података
тј. садржај обе листе.</p>
<p>Ако желимо да прикажемо садржај елемената реда у једној листи (дакле,
онако како га замишљамо, а не како је имплементиран), можемо
дефинисати своју функцију приказа у облику ниске карактера. То можемо
урадити на следећи начин.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">show</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Queue</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">String</span>
<span class="nf">show</span><span class="w"> </span><span class="p">(</span><span class="kt">Queue</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="n">right</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">show</span><span class="w"> </span><span class="p">(</span><span class="n">right</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">reverse</span><span class="w"> </span><span class="n">left</span><span class="p">)</span>
</pre></div>
</div>
<p>Ниску добијамо тако што спојимо десну и обрнуту леву листу (тиме је
елемент који је први на реду за скидање приказан на
почетку). Приметите да ту листу претварамо у ниску позивом функције
<code class="docutils literal notranslate"><span class="pre">show</span></code>, међутим, ово није рекурзивни позив јер је позвана функција
<code class="docutils literal notranslate"><span class="pre">show</span></code> другог типа (она претвара листу, а не ред у ниску карактера).</p>

    <div class="note-wrapper infonote-type">
        <div class="note-icon-holder"> </div>
        <img src="/_runestone/_static/img/infonote-img.svg" class="note-image infonote-image"> 
        <div class="course-content">
            
<p>Претходна функција <code class="docutils literal notranslate"><span class="pre">show</span></code> се користи када је корисник експлицитно
позове, али неће бити позивана аутоматски када год је потребно да
се неки ред прикаже на екрану. Да би се то постигло, морамо да
користимо механизам класа типова тј. да нагласимо да наш тип
<code class="docutils literal notranslate"><span class="pre">Queue</span></code> припада класи типова <code class="docutils literal notranslate"><span class="pre">Show</span></code>, при чему се за приказ не
користи аутоматски генерисана функција (добијена клаузулом
<code class="docutils literal notranslate"><span class="pre">deriving</span> <span class="pre">Show</span></code>), већ специфична функција коју ми дефинишемо.  Да
би се то урадило, користи се клаузула <code class="docutils literal notranslate"><span class="pre">instance</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span><span class="w"> </span><span class="kt">Show</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Show</span><span class="w"> </span><span class="p">(</span><span class="kt">Queue</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span>
<span class="w">   </span><span class="n">show</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Queue</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">String</span>
<span class="w">   </span><span class="n">show</span><span class="w"> </span><span class="p">(</span><span class="kt">Queue</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="n">right</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">show</span><span class="w"> </span><span class="p">(</span><span class="n">right</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">reverse</span><span class="w"> </span><span class="n">left</span><span class="p">)</span>
</pre></div>
</div>
<p>Овим смо рекли да тип <code class="docutils literal notranslate"><span class="pre">Queue</span> <span class="pre">a</span></code> припада класи типова <code class="docutils literal notranslate"><span class="pre">Show</span></code>
тј. може да се прикаже (део <code class="docutils literal notranslate"><span class="pre">Show</span> <span class="pre">(Queue</span> <span class="pre">a)</span></code>), међутим, то важи
само под условом да тип <code class="docutils literal notranslate"><span class="pre">а</span></code> припада класи <code class="docutils literal notranslate"><span class="pre">Show</span></code> тј. може да се
прикаже (део <code class="docutils literal notranslate"><span class="pre">Show</span> <span class="pre">a</span> <span class="pre">=&gt;</span></code>). Затим дефинишемо функцију <code class="docutils literal notranslate"><span class="pre">show</span></code>
која дати ред представља у облику ниске карактера.</p>

    </div></div>
</section>
<section id="id4">
<h2>Вежба – алгебарски типови података</h2>
<p>Као вежбу алгебарских типова података имплементирајмо структуру
података <em>речник</em>.</p>

    <div class="note-wrapper questionnote-type">
        <div class="note-icon-holder"> </div>
        <img src="/_runestone/_static/img/question-mark.png" class="note-image questionnote-image"> 
        <div class="course-content">
<p>Дефинисати тип података за представљање речника (мапе) елемената
типа <code class="docutils literal notranslate"><span class="pre">k</span></code> у елементе типа <code class="docutils literal notranslate"><span class="pre">v</span></code>. Речник треба да буде реализован
помоћу уређеног бинарног дрвета.</p>

    </div></div>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">Map</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="ow">=</span><span class="w">  </span><span class="kt">Null</span>
<span class="w">              </span><span class="o">|</span><span class="w"> </span><span class="kt">Node</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="p">(</span><span class="kt">Map</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="kt">Map</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="p">)</span>
<span class="w">              </span><span class="kr">deriving</span><span class="w"> </span><span class="kt">Show</span>
</pre></div>
</div>

    <div class="note-wrapper questionnote-type">
        <div class="note-icon-holder"> </div>
        <img src="/_runestone/_static/img/question-mark.png" class="note-image questionnote-image"> 
        <div class="course-content">
<p>Дефинисати функцију која проверава да ли је речник празан.</p>

    </div></div>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">empty</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Map</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Bool</span>
<span class="nf">empty</span><span class="w"> </span><span class="kt">Null</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">True</span>
<span class="nf">empty</span><span class="w"> </span><span class="kr">_</span><span class="w">    </span><span class="ow">=</span><span class="w"> </span><span class="kt">False</span>
</pre></div>
</div>

    <div class="note-wrapper questionnote-type">
        <div class="note-icon-holder"> </div>
        <img src="/_runestone/_static/img/question-mark.png" class="note-image questionnote-image"> 
        <div class="course-content">
<p>Дефинисати функције за уметање тј. ажурирање вредности у речнику.</p>
<ul class="simple">
<li><p>Дефинисати прво функцију <code class="docutils literal notranslate"><span class="pre">insertWithKey</span></code> која датом кључу
придружује дату вредност ако тај кључ већ не постоји у речнику, а
ако постоји онда му придружује нову вредност применом задате
функције на тај кључ, стару вредност и нову вредност.</p></li>
<li><p>Коришћењем претходне функције дефинисати затим функцију
<code class="docutils literal notranslate"><span class="pre">insert</span></code>, која датом кључу придружује дату вредност (ако кључ
већ постоји у речнику, стара вредност се занемарује).</p></li>
</ul>

    </div></div>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">insertWithKey</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Ord</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Map</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Map</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span>
<span class="nf">insertWithKey</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="kt">Null</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Node</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="kt">Null</span><span class="w"> </span><span class="kt">Null</span>
<span class="nf">insertWithKey</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="p">(</span><span class="kt">Node</span><span class="w"> </span><span class="n">k'</span><span class="w"> </span><span class="n">v'</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="n">r</span><span class="p">)</span>
<span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">k'</span><span class="w">   </span><span class="ow">=</span><span class="w"> </span><span class="kt">Node</span><span class="w"> </span><span class="n">k'</span><span class="w"> </span><span class="n">v'</span><span class="w"> </span><span class="p">(</span><span class="n">insertWithKey</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="n">l</span><span class="p">)</span><span class="w"> </span><span class="n">r</span>
<span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">k'</span><span class="w">   </span><span class="ow">=</span><span class="w"> </span><span class="kt">Node</span><span class="w"> </span><span class="n">k'</span><span class="w"> </span><span class="n">v'</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="p">(</span><span class="n">insertWithKey</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="n">r</span><span class="p">)</span>
<span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">k'</span><span class="w">  </span><span class="ow">=</span><span class="w"> </span><span class="kt">Node</span><span class="w"> </span><span class="n">k'</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v'</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="n">r</span>

<span class="nf">insert</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Ord</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Map</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Map</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span>
<span class="nf">insert</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">insertWith</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="n">v'</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">v'</span><span class="p">)</span>
</pre></div>
</div>

    <div class="note-wrapper questionnote-type">
        <div class="note-icon-holder"> </div>
        <img src="/_runestone/_static/img/question-mark.png" class="note-image questionnote-image"> 
        <div class="course-content">
<p>Дефинисати функцију која листу парова (кључ, вредност) претвара у
речник.</p>

    </div></div>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">fromList</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Ord</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="p">[(</span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">)]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Map</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span>
<span class="nf">fromList</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">foldl</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">m</span><span class="w"> </span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">insert</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="kt">Null</span>
</pre></div>
</div>

    <div class="note-wrapper questionnote-type">
        <div class="note-icon-holder"> </div>
        <img src="/_runestone/_static/img/question-mark.png" class="note-image questionnote-image"> 
        <div class="course-content">
<p>Дефинисати функцију <code class="docutils literal notranslate"><span class="pre">find</span></code>, која проналази вредност придружену
датом кључу у речнику. Резултат треба да буде типа <code class="docutils literal notranslate"><span class="pre">Maybe</span> <span class="pre">v</span></code>, што
значи да треба да буде <code class="docutils literal notranslate"><span class="pre">Nothing</span></code> ако кључ не постоји у речнику,
односно <code class="docutils literal notranslate"><span class="pre">Just</span> <span class="pre">v</span></code> ako je кључу придружена вредност <code class="docutils literal notranslate"><span class="pre">v</span></code>.</p>
<p>Коришћењем функције <code class="docutils literal notranslate"><span class="pre">find</span></code> дефинисати функцију
<code class="docutils literal notranslate"><span class="pre">findWithDefault</span></code>, која враћа вредност придружену датом кључу или
задату подразумевану вредност ако кључ не постоји у речнику.</p>
<p>Коришћењем функције <code class="docutils literal notranslate"><span class="pre">find</span></code> дефинисати функцију <code class="docutils literal notranslate"><span class="pre">containsKey</span></code>,
која за дату мапу враћа функцију која проверава да ли кључ постоји
у речнику.</p>

    </div></div>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">find</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Ord</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Map</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Maybe</span><span class="w"> </span><span class="n">v</span>
<span class="nf">find</span><span class="w"> </span><span class="kt">Null</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Nothing</span>
<span class="nf">find</span><span class="w"> </span><span class="p">(</span><span class="kt">Node</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="n">k'</span>
<span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="n">k'</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">k</span><span class="w">  </span><span class="ow">=</span><span class="w"> </span><span class="n">find</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="n">k'</span>
<span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="n">k'</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">k</span><span class="w">  </span><span class="ow">=</span><span class="w"> </span><span class="n">find</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="n">k'</span>
<span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="n">k'</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Just</span><span class="w"> </span><span class="n">v</span>

<span class="nf">findWithDefault</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Ord</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Map</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">v</span>
<span class="nf">findWithDefault</span><span class="w"> </span><span class="n">dflt</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">case</span><span class="w"> </span><span class="n">find</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="kr">of</span><span class="w"> </span><span class="kt">Nothing</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">dflt</span>
<span class="w">                                            </span><span class="kt">Just</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">v</span>

<span class="nf">containsKey</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Ord</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Map</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Bool</span><span class="p">)</span>
<span class="nf">containsKey</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">case</span><span class="w"> </span><span class="n">search</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="kr">of</span><span class="w"> </span><span class="kt">Nothing</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">False</span>
<span class="w">                                     </span><span class="kt">Just</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">True</span>
</pre></div>
</div>

    <div class="note-wrapper questionnote-type">
        <div class="note-icon-holder"> </div>
        <img src="/_runestone/_static/img/question-mark.png" class="note-image questionnote-image"> 
        <div class="course-content">
<p>Дефинисати функцију <code class="docutils literal notranslate"><span class="pre">adjustWithKey</span></code> која мења вредност датом
кључу тако што нову вредност одређује применом дате функције на
кључ и стару вредност.</p>

    </div></div>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">adjustWithKey</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Ord</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Map</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Map</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span>
<span class="nf">adjustWithKey</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="kt">Null</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Null</span>
<span class="nf">adjustWithKey</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="p">(</span><span class="kt">Node</span><span class="w"> </span><span class="n">k'</span><span class="w"> </span><span class="n">v'</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="n">r</span><span class="p">)</span>
<span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">k'</span><span class="w">   </span><span class="ow">=</span><span class="w"> </span><span class="kt">Node</span><span class="w"> </span><span class="n">k'</span><span class="w"> </span><span class="n">v'</span><span class="w"> </span><span class="p">(</span><span class="n">adjustWithKey</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">l</span><span class="p">)</span><span class="w"> </span><span class="n">r</span>
<span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">k'</span><span class="w">   </span><span class="ow">=</span><span class="w"> </span><span class="kt">Node</span><span class="w"> </span><span class="n">k'</span><span class="w"> </span><span class="n">v'</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="p">(</span><span class="n">adjustWithKey</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">r</span><span class="p">)</span>
<span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">k'</span><span class="w">  </span><span class="ow">=</span><span class="w"> </span><span class="kt">Node</span><span class="w"> </span><span class="n">k'</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v'</span><span class="p">)</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="n">r</span>
</pre></div>
</div>

    <div class="note-wrapper questionnote-type">
        <div class="note-icon-holder"> </div>
        <img src="/_runestone/_static/img/question-mark.png" class="note-image questionnote-image"> 
        <div class="course-content">
<p>Дефинисати функцију која уклања најмањи кључ из речника.</p>
<p>Дефинисати затим функцију која уклања дати кључ из речника.</p>

    </div></div>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">deleteMin</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Map</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">((</span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">),</span><span class="w"> </span><span class="kt">Map</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="p">)</span>
<span class="nf">deleteMin</span><span class="w"> </span><span class="p">(</span><span class="kt">Node</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="kt">Null</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">((</span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">),</span><span class="w"> </span><span class="n">r</span><span class="p">)</span>
<span class="nf">deleteMin</span><span class="w"> </span><span class="p">(</span><span class="kt">Node</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">let</span><span class="w"> </span><span class="p">((</span><span class="n">k'</span><span class="p">,</span><span class="w"> </span><span class="n">v'</span><span class="p">),</span><span class="w"> </span><span class="n">d</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">deleteMin</span><span class="w"> </span><span class="n">l</span>
<span class="w">                            </span><span class="kr">in</span><span class="w"> </span><span class="p">((</span><span class="n">k'</span><span class="p">,</span><span class="w"> </span><span class="n">v'</span><span class="p">),</span><span class="w"> </span><span class="kt">Node</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="n">r</span><span class="p">)</span>

<span class="nf">delete</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Ord</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Map</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Map</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span>
<span class="nf">delete</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="kt">Null</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Null</span>
<span class="nf">delete</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="p">(</span><span class="kt">Node</span><span class="w"> </span><span class="n">k'</span><span class="w"> </span><span class="n">v'</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="n">r</span><span class="p">)</span>
<span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">k'</span><span class="w">  </span><span class="ow">=</span><span class="w"> </span><span class="kt">Node</span><span class="w"> </span><span class="n">k'</span><span class="w"> </span><span class="n">v'</span><span class="w"> </span><span class="p">(</span><span class="n">delete</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">l</span><span class="p">)</span><span class="w"> </span><span class="n">r</span>
<span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">k'</span><span class="w">  </span><span class="ow">=</span><span class="w"> </span><span class="kt">Node</span><span class="w"> </span><span class="n">k'</span><span class="w"> </span><span class="n">v'</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="p">(</span><span class="n">delete</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">r</span><span class="p">)</span>
<span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">k'</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">case</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="kr">of</span><span class="w"> </span><span class="kt">Null</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">l</span>
<span class="w">                       </span><span class="kr">_</span><span class="w">    </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kr">let</span><span class="w"> </span><span class="p">((</span><span class="n">k'</span><span class="p">,</span><span class="w"> </span><span class="n">v'</span><span class="p">),</span><span class="w"> </span><span class="n">d</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">deleteMin</span><span class="w"> </span><span class="n">r</span>
<span class="w">                                </span><span class="kr">in</span><span class="w"> </span><span class="kt">Node</span><span class="w"> </span><span class="n">k'</span><span class="w"> </span><span class="n">v'</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="n">d</span>
</pre></div>
</div>

    <div class="note-wrapper questionnote-type">
        <div class="note-icon-holder"> </div>
        <img src="/_runestone/_static/img/question-mark.png" class="note-image questionnote-image"> 
        <div class="course-content">
<p>Дефинисати функционал <code class="docutils literal notranslate"><span class="pre">fold</span></code> за речник. Он као први аргумент
прима функцију која на основу претходног резултата, кључа и
вредности придружене кључу ажурира резултат, као други аргумент
прима почетну вредност резултата, а као трећи аргумент прима
речник.</p>
<p>Коришћењем тако дефинисаног функционала <code class="docutils literal notranslate"><span class="pre">fold</span></code> дефинисати
функцију <code class="docutils literal notranslate"><span class="pre">size</span></code>, која израчунава величину речника (број кључева у
речнику), затим функцију <code class="docutils literal notranslate"><span class="pre">toList</span></code>, која креира листу парова (кључ,
вредност) из речника, сортирану по кључевима и на крају функцију
<code class="docutils literal notranslate"><span class="pre">union</span></code> која прави унију два речника (ако кључ постоји у оба
речника потребно је придружити му вредност из другог).</p>

    </div></div>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">foldMap</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Map</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span>
<span class="nf">foldMap</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="kt">Null</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">i</span>
<span class="nf">foldMap</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="p">(</span><span class="kt">Node</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span>
<span class="w">  </span><span class="n">foldlMap</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="n">foldlMap</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="n">l</span><span class="p">)</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="n">r</span>

<span class="nf">size</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Map</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span>
<span class="nf">size</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">foldMap</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="mi">0</span>

<span class="nf">toList</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Ord</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Map</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[(</span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">)]</span>
<span class="nf">toList</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">reverse</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">foldlMap</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="kt">[]</span>

<span class="nf">union</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Ord</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Map</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Map</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Map</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span>
<span class="nf">union</span><span class="w"> </span><span class="n">m1</span><span class="w"> </span><span class="n">m2</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">foldlMap</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">insert</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="n">m1</span><span class="w"> </span><span class="n">m2</span>
</pre></div>
</div>
</section>
</section>


    
                <div class="finish-lecture-label" id="finishLectureLabel-7788">Mark activity as completed</div>
                <button type="button" class="finish-lecture-btn not-checked-finish-activity" id="finishLecture-7788" aria-labelledby="MarkLectureComplitedBtn">
                    <img src="/images/check (2) 2@3x.png" alt="Icon for marking the activity as completed">
                </button>
                <div role="button" class="finish-lecture-btn checked-finish-activity d-none" id="checkmark-7788" aria-labelledby="LectureMarkedComplitedBtn">
                    <div class="checked-finish-activity-label">
                        Activity completed!
                    </div>
                    <img src="/images/check (2) 2@3x white.png" alt="Icon indicating the activity is completed">
                </div>
                <div class="lecture-prev-next-toggle">
                    <button type="button" id="prevLecture" class="lecture-toggler-arrows" aria-labelledby="Button to go on previous activity">
                        <span aria-hidden="true">
                            <i class="fas fa-arrow-left fa"></i>
                        </span>
                        <span class="lecture-toggler-arrows-text">Previous activity</span>
                    </button>

                    <button type="button" id="nextLecture" class="lecture-toggler-arrows" aria-labelledby="Button to go on next activity">
                        <span class="lecture-toggler-arrows-text">Next activity</span>
                        <span aria-hidden="true">
                            <i class="fas fa-arrow-right fa"></i>
                        </span>
                    </button>
                </div>
            </div>
</body>
</html>