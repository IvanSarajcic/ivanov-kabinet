# Час 3: Процедурална и објектно-оријентисана парадигма
**Тип часа:** Обрада новог градива  
**Трајање:** 45 минута

## Циљ часа
Ученици ће упознати процедуралну и објектно-оријентисану парадигму програмирања, њихове основне карактеристике и разлике између њих.

## Исходи часа
По завршетку часа ученик ће бити у стању да:
- дефинише процедуралну парадигму програмирanja
- објасни основне концепте објектно-оријентисане парадигме
- наведе главне разлике између процедуралне и ОО парадигме
- препозна елементе сваке парадигме у програмском коду
- објасни предности и недостатке сваког приступа

---

## Садржај часа

### 1. УВОД И ПОНАВЉАЊЕ (5 минута)
**Мотивациона питања:**
- Које програмске језике сте до сада користили?
- Да ли сте приметили разлике у начину организације кода између C-ја и Java-е?
- Шта је то што чини Java програм "другачијим" од C програма?

### 2. ПРОЦЕДУРАЛНА ПАРАДИГМА (15 минута)

#### Шта је процедурална парадигма?
**Процедурална парадигма** је проширење императивне парадигме где се:
- Програм организује као **скуп процедура/функција**
- Свака процедура решава **одређени подпроблем**
- **Подаци и функције су одвојени**
- Програм се извршава **позивима функција**

#### Основне карактеристике:
1. **Подела на функције** - "divide and conquer" приступ
2. **Глобални подаци** - доступни свим функцијама  
3. **Локални подаци** - видљиви само у функцији
4. **Параметри функција** - начин комуникације
5. **Хијерархијска структура** - main позива друге функције

#### Пример у C-у:
```c
// Глобалне променљиве
int brojStudenata = 0;
float ocene[100];

// Процедуре/функције
void unesiOcenu(float ocena) {
    ocene[brojStudenata] = ocena;
    brojStudenata++;
}

float izracunajProsek() {
    float suma = 0;
    for(int i = 0; i < brojStudenata; i++) {
        suma += ocene[i];
    }
    return suma / brojStudenata;
}

int main() {
    unesiOcenu(8.5);
    unesiOcenu(9.0);
    printf("Prosek: %.2f", izracunajProsek());
    return 0;
}
```

#### Предности процедуралне парадигме:
- ✅ **Једноставност** - лако за разумевање
- ✅ **Модуларност** - подела на функције
- ✅ **Поновна употреба** - исте функције више пута
- ✅ **Дебагирање** - лакше налажење грешака

#### Проблеми процедуралне парадигме:
- ❌ **Глобални подаци** - могу се случајно изменити
- ❌ **Слаба енкапсулација** - подаци нису заштићени
- ❌ **Сложеност** - тешко управљање великих програма
- ❌ **Зависности** - промене утичу на многе функције

### 3. ОБЈЕКТНО-ОРИЈЕНТИСАНА ПАРАДИГМА (20 минута)

#### Шта је објектно-оријентисана парадигма?
**Објектно-оријентисана парадигма** је приступ где се:
- Програм моделује као **скуп објеката**
- Објекти **комуницирају слањем порука**
- **Подаци и методе су заједно** у класама
- Фокус је на **"ко ради шта"** уместо "како се ради"

#### Основни концепти ОО парадигме:

##### А) Класа и објекат
- **Класа** = шаблон/нацрт за стварање објеката
- **Објекат** = конкретна инстанца класе
- **Атрибути** = подаци објекта (својства)
- **Методе** = функције објекта (понашање)

##### Б) Енкапсулација
- **Скривање детаља** имплементације
- **Контролисан приступ** подацима
- **Јавни интерфејс** vs **приватна имплементација**

##### В) Наслеђивање
- **Створи нову класу** на основу постојеће
- **Наследи атрибуте и методе** родитељске класе
- **Прошири или измени** понашање

##### Г) Полиморфизам
- **Исти интерфејс** - различито понашање
- **Различити објекти** реагују различито на исту поруку

#### Пример у Java-и:
```java
// Класа као шаблон
class Student {
    // Атрибути (приватни подаци)
    private String ime;
    private float[] ocene;
    private int brojOcena;
    
    // Конструктор
    public Student(String ime) {
        this.ime = ime;
        this.ocene = new float[20];
        this.brojOcena = 0;
    }
    
    // Методе (понашање)
    public void dodajOcenu(float ocena) {
        if(brojOcena < 20) {
            ocene[brojOcena] = ocena;
            brojOcena++;
        }
    }
    
    public float getProsek() {
        if(brojOcena == 0) return 0;
        float suma = 0;
        for(int i = 0; i < brojOcena; i++) {
            suma += ocene[i];
        }
        return suma / brojOcena;
    }
    
    public String getIme() {
        return ime;
    }
}

// Коришћење
public class Main {
    public static void main(String[] args) {
        Student marko = new Student("Marko");
        marko.dodajOcenu(8.5f);
        marko.dodajOcenu(9.0f);
        
        System.out.println(marko.getIme() + 
                          ": " + marko.getProsek());
    }
}
```

### 4. ПОРЕЂЕЊЕ ПАРАДИГМИ (4 минута)

| Аспект | Процедурална | Објектно-оријентисана |
|--------|--------------|----------------------|
| **Фокус** | Функције и процедуре | Објекти и класе |
| **Подаци** | Глобални, одвојени | Енкапсулирани у објектима |
| **Организација** | Функције позивају функције | Објекти шаљу поруке |
| **Модуларност** | По функцијама | По класама |
| **Поновна употреба** | Функције | Наслеђивање, полиморфизам |
| **Сложеност** | Тешко за велике системе | Боље за велике системе |
| **Учење** | Једноставније | Комплексније концепти |

#### Када користити коју парадигму?

**Процедуралну:**
- Мањи, једноставнији програми
- Математички прорачуни
- Системско програмирање
- Скриптови и алати

**Објектно-оријентисану:**
- Велики, сложени системи
- GUI апликације
- Игре и симулације
- Веб апликације
- Тимски развој

### 5. ПРАКТИЧНИ ПРИМЕР - ИСТИ ПРОБЛЕМ (1 минут)

**Задатак:** Управљање библиотеком књига

**Процедурални приступ:**
```c
struct Knjiga knjige[100];
int brojKnjiga = 0;

void dodajKnjigu(char* naslov, char* autor) { /* ... */ }
void prikaziKnjige() { /* ... */ }
struct Knjiga* nadjiKnjigu(char* naslov) { /* ... */ }
```

**ОО приступ:**
```java
class Biblioteka {
    private List<Knjiga> knjige;
    
    public void dodajKnjigu(Knjiga knjiga) { /* ... */ }
    public void prikaziKnjige() { /* ... */ }
    public Knjiga nadjiKnjigu(String naslov) { /* ... */ }
}
```

---

## Закључак часа
- **Процедурална парадигма** = организација кроз функције
- **ОО парадигма** = организација кроз објекте и класе
- **Енкапсулација** решава проблеме глобалних података
- **Наслеђивање и полиморфизам** омогућавају флексибилност
- Свака парадигма има своју примену

---

## Материјали за час
- Табла/пројектор за дијаграме класа
- Примери кода у C и Java
- Дијаграм поређења парадигми

## Домаћи задатак
1. **Модификовати** процедурални пример са студентима - додати функцију за брисање оцене
2. **Направити класу** `Proizvod` са атрибутима (назив, цена, количина) и методама за рад са њима
3. **Размислити:** зашто је боље да атрибути буду приватни, а методе јавне?

## Напомене за наставника
- Користити дијаграме за илустрацију концепата
- Нагласити да ОО није увек боље - зависи од проблема
- Показати како се исти проблем решава у обе парадигме
- Припремити примере наслеђивања за следећи час
- Подстицати питања о енкапсулацији