# Коректност алгоритама и програма

**Алгоритам** је прецизан опис поступка за решавање неког проблема у коначном броју корака.

Исправност тј. коректност је суштинска особина алгоритама и програма. Иако се некада у пракси користе програми за које се зна да понекад могу да дају и нетачне резултате, то најчешће није случај и од програма се захтева да буде практично апсолутно непогрешив.

## Облици испитивања коректности

Поступак показивања да је програм исправан назива се верификовање програма. Два основна приступа верификацији су:

1. **Динамичка верификација**: подразумева проверу исправности у фази извршавања програма, најчешће путем тестирања.
2. **Статичка верификација**: подразумева анализу изворног кода програма, често коришћењем формалних метода и математичког апарата.

Систематично тестирање је сигурно најзначајнији облик постизања високог степена исправности програма. Међутим, тестирањем се не може показати да је програм коректан, већ само да **није** коректан.

## Аспекти коректности

Коректност се огледа кроз два аспекта:

*   **Парцијална коректност**: свака вредност коју алгоритам израчуна за улазне параметре који задовољавају спецификацију мора да буде тачна.
*   **Заустављање**: алгоритам мора да се заустави за све улазе који задовољавају спецификацију.

Алгоритам који је и парцијално коректан и који се зауставља назива се **тотално коректан**.

## Честе грешке при прављењу програма (са примерима у C++)

### 1. Грешка погрешног избора типа (Overflow)

Ова грешка настаје када изабрани тип података не може да прими резултат операције.

**Пример:** Рачунање факторијела.

```cpp
// Погрешно: int може да сачува вредности само до око 2*10^9.
// Факторијел броја 13 је већ 6,227,020,800 што превазилази int.
int faktorijel(int n) {
    int f = 1;
    for (int i = 1; i <= n; i++)
        f *= i;
    return f;
}

// Исправно: користити long long за веће бројеве
long long faktorijel_ispravno(int n) {
    long long f = 1;
    for (int i = 1; i <= n; i++)
        f *= i;
    return f;
}
```

### 2. Грешка за 1 (Off-by-one)

Настаје када погрешимо границу петље или индекса за један.

**Пример:** Сабирање елемената низа.

```cpp
#include <vector>
using namespace std;

int zbir_niza(const vector<int>& a) {
    int s = 0;
    // Погрешно: петља иде до <= a.size(), што приступа елементу ван низа!
    // Индекси иду од 0 до a.size() - 1.
    for (int i = 0; i <= a.size(); i++) { 
        s += a[i];
    }
    return s;
}

int zbir_niza_ispravno(const vector<int>& a) {
    int s = 0;
    // Исправно: строго мање од a.size()
    for (int i = 0; i < a.size(); i++) {
        s += a[i];
    }
    return s;
}
```

### 3. Грешка прекорачења граница низа (Buffer Overflow)

У C++ се не врши аутоматска провера граница низа, па је ово чест узрок рушења програма или неочекиваног понашања.

**Пример:** Формирање префиксног низа.

```cpp
void prefiksni_zbir(const vector<int>& a, vector<int>& b) {
    int n = a.size();
    b.resize(n);
    b[0] = a[0];
    // Погрешно: ако је i = n-1, онда i+1 приступа b[n] и a[n] што је ван граница
    for (int i = 0; i < n; i++) {
        b[i+1] = b[i] + a[i+1]; 
    }
}
```

### 4. Грешка непотпуних услова

Када пишемо условне конструкције, морамо водити рачуна да покријемо све случајеве, укључујући и када су неки параметри једнаки.

**Пример:** Функција за проналажење минимума три броја.

```cpp
// Погрешно: не ради када су бројеви једнаки
int Min(int a, int b, int c) {
    if (a < b && a < c) return a;
    else if (b < c) return b;
    else return c;
}

// Проблем: за улаз (1, 1, 3), први услов није испуњен (1 није строго мање од 1),
// други услов враћа b = 1, али то је само случајно тачно.
// За улаз (3, 1, 1), први услов није испуњен, други такође (1 није строго мање од 1),
// функција враћа c = 1, али опет само случајно тачно.

// Исправно: користити <= за покривање случајева једнакости
int Min_ispravno(int a, int b, int c) {
    if (a <= b && a <= c) return a;
    else if (b <= c) return b;
    else return c;
}
```

### 5. Необраћање пажње на специјалне случајеве

Програми често падају на "ивичним случајевима" (edge cases), као што су празни низови, негативни бројеви, или нуле.

**Пример:** Проналажење максимума.

```cpp
int maksimum(const vector<int>& a) {
    // Погрешно: Шта ако је низ празан? a[0] ће изазвати грешку.
    int max_val = a[0]; 
    for (size_t i = 1; i < a.size(); i++) {
        if (a[i] > max_val) max_val = a[i];
    }
    return max_val;
}

// Исправно: Провера да ли је низ празан
#include <stdexcept>

int maksimum_ispravno(const vector<int>& a) {
    if (a.empty()) {
        throw runtime_error("Niz je prazan!");
    }
    int max_val = a[0];
    for (size_t i = 1; i < a.size(); i++) {
        if (a[i] > max_val) max_val = a[i];
    }
    return max_val;
}
```

## Важност свеобухватног тестирања

Када тестирамо функције, важно је покрити све могуће случајеве:

**Пример:** За функцију која сортира три броја, не можемо тестирати само један случај као (1, 2, 3).

Морамо тестирати све пермутације:
- (1, 2, 3) — већ сортирано
- (1, 3, 2) — замена последња два
- (2, 1, 3) — замена прва два
- (2, 3, 1) — ротација
- (3, 1, 2) — ротација
- (3, 2, 1) — обрнут редослед

Такође треба тестирати случајеве са једнаким вредностима:
- (1, 1, 2)
- (1, 2, 1)
- (2, 1, 1)
- (1, 1, 1)
