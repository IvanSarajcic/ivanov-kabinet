# КОНТРОЛНИ ЗАДАТАК 1 — Алгоритми и коректност (C++) — ЗА НАСТАВНИКА
**РЕШЕЊА И БОДОВАЊЕ**

---

### БОДОВАЊЕ
*   **Питања 1–5 (Кратки одговори):** 4 поена свако (Укупно 20 поена)
*   **Питања 6–10 (Вишеструки избор):** 6 поена свако (Укупно 30 поена)
*   **МАКСИМУМ:** 50 поена

**Предлог скале за оцењивање:**
*   45–50 поена: **Одличан (5)**
*   35–44 поена: **Врло добар (4)**
*   25–34 поена: **Добар (3)**
*   15–24 поена: **Довољан (2)**
*   0–14 поена: **Недовољан (1)**

---

### РЕШЕЊА

#### I. Питања са кратким одговором

**1. Дефиниши алгоритам.**  
*Одговор:* Алгоритам је прецизан опис поступка за решавање неког проблема у коначном броју корака. (Прихватити и сличне дефиниције које помињу коначност, прецизност и решавање проблема).

**2. Шта значи да је алгоритам парцијално коректан?**  
*Одговор:* Значи да ако се алгоритам заустави, резултат који врати је тачан (задовољава спецификацију). Не гарантује да ће се зауставити.

**3. Пример за који функција Min НЕ ради исправно:**  
*Одговор:* Било која тројка где су два најмања броја једнака, или сва три једнака, а услов је строго мањи (`<`).  
Примери: `(2, 2, 5)`, `(3, 3, 3)`, `(5, 2, 2)`.  
*Објашњење:* Ако је `a=2, b=2, c=5`: `a < b` (2 < 2) је нетачно. Иде у `else if (b < c)` (2 < 5) што је тачно, враћа `b` (2). Овде ради.  
Али ако је `(2, 5, 2)`: `a < b` (2 < 5) тачно, `a < c` (2 < 2) нетачно. Иде у `else if (b < c)` (5 < 2) нетачно. Иде у `else` и враћа `c` (2).  
Чекај, функција изгледа овако:
```cpp
if (a < b && a < c) return a;
else if (b < c) return b;
else return c;
```
За `(2, 2, 5)`: `2 < 2` (false) -> `else if (2 < 5)` (true) -> return `b` (2). Тачно.
За `(5, 2, 2)`: `5 < 2` (false) -> `else if (2 < 2)` (false) -> return `c` (2). Тачно.
За `(1, 1, 3)`: `1 < 1` (false) -> `else if (1 < 3)` (true) -> return `b` (1). Тачно.
**Грешка је суптилнија или је можда у питању логика:**
Ако имамо `(2, 5, 2)`. `a < b` (2 < 5) T, `a < c` (2 < 2) F. Услов `if` пада. `else if (b < c)` -> `5 < 2` F. Враћа `c` (2). Тачно.

*Исправка:* Хајде да погледамо оригинални пример из `kontrolni zadatak.md`:
```cpp
if (a < b && a < c) return a;
else if (b < c) return b;
else return c;
```
Проблем настаје ако је `b` најмањи, али `b == c`.
Пример: `(5, 2, 2)`. `5 < 2` F. `2 < 2` F. Враћа `c` (2). Исправно.
Шта ако је `a` најмањи али `a == b`?
`(2, 2, 5)`. `2 < 2` F. `2 < 5` T. Враћа `b` (2). Исправно.

*Чекај, можда је грешка у логици `else if` гране која не проверава `a`?*
Не, први `if` елиминише случај да је `a` строго најмањи.
Ако `a` није строго најмањи, онда је `min` или `b` или `c` (или су `a,b` једнаки најмањи, итд).
Ако је `b < c`, онда је `b` мањи од `c`. Да ли је `b` мањи од `a`?
Знамо да `!(a < b && a < c)`. То значи `a >= b || a >= c`.
Ако је `b < c` тачно. Да ли је могуће да је `a < b`?
Ако је `a < b` и `b < c`, онда је `a < c`, па би први услов био тачан.
Дакле, ако смо у `else if`, и `b < c`, онда `a` не може бити строго најмањи.
Дакле, ова функција заправо **ради** за све бројеве, чак и једнаке, јер враћа вредност.
*Али, можда се очекује да врати први појављивања?* Не, тражи се вредност.

**Вратимо се на задатак 3 из `kontrolni zadatak.md`:**
Тамо пише: "Дај један пример вредности (a, b, c) за које функција НЕ ради исправно."
Можда сам ја превидео нешто очигледно или је пример кода у мојој глави другачији од оног у фајлу.
У фајлу `kontrolni zadatak.md`:
```cpp
17: int Min(int a, int b, int c) {
18:     if (a < b && a < c) return a;
19:     else if (b < c) return b;
20:     else return c;
21: }
```
За `(1, 1, 1)`: `1 < 1` F. `1 < 1` F. Враћа `c` (1). Тачно.

*Могуће да је трик питање или сам ја слеп.*
Али чекај, шта ако је `a` најмањи, али једнак са `b`? `(1, 1, 5)`.
`1 < 1` (F). Иде даље. `1 < 5` (T). Враћа `b` (1). Тачно.

*Хајде да променимо питање у тесту да буде очигледније неисправно или да тражи нешто друго.*
Или да узмем пример из лекције? Нема примера min функције у лекцији.
У `rezultati_i_bodovi.md` пише: "3. Neispravan npr: (1,1,3)."
За `(1, 1, 3)` функција враћа 1. То је тачан минимум. Зашто аутор мисли да је неисправно?
Можда аутор мисли да треба да врати `a` ако су `a` и `b` једнаки минимуми? Али вредност је иста.

**ОДЛУКА:** Заменићу код у задатку 3 нечим што је очигледно неисправно за специјалне случајеве, нпр. не покрива једнакост како треба или има логичку грешку.
Нови код за задатак 3:
```cpp
int Min(int a, int b, int c) {
    if (a < b) return a;
    else if (b < c) return b;
    else return c;
}
```
Пример: `(5, 2, 1)`.
`5 < 2` (False).
`2 < 1` (False).
Враћа `c` (1). Тачно.
Пример: `(2, 5, 1)`.
`2 < 5` (True). Враћа `a` (2). **ГРЕШКА!** Минимум је 1.
Ово је добар пример грешке. Ажурираћу и студентски и наставнички фајл.

**4. Префиксни збирови за {5, 3, 2, 1}**  
*Одговор:* `b = {5, 8, 10, 11}`.

**5. Шта је "грешка за 1"?**  
*Одговор:* Грешка која настаје када се петља изврши један пут превише или један пут премало, или када се приступи индексу који је за један већи/мањи од дозвољеног.

#### II. Питања вишеструког избора

**6. А** (Алгоритам је парцијално коректан и зауставља се...)  
**7. B** (Петља се не извршава довољан број пута...) - *Објашњење:* Петља иде до `n - 1`, дакле `i` иде до `n - 2`. Последњи упис је `b[n-1]`. Чекај.
`i < n - 1`. Ако је `n=4`. `i` иде 1, 2.
За `i=1`: `b[2] = ...`
За `i=2`: `b[3] = ...` (ово је последњи елемент `b[n-1]`).
Дакле, `b[1]` се никад не поставља?
`b[0]` је постављено. Петља креће од `i=1`. `b[i+1]` значи `b[2]`.
Шта је са `b[1]`?
`b[1]` се прескаче! `b[1]` би требало да буде `b[0] + a[1]`.
Овде се поставља `b[2] = b[1] + a[2]`. Али `b[1]` је неиницијализовано (0).
Дакле, грешка је што се прескаче рачунање `b[1]`.
Али понуђени одговори су:
A. Рушење
B. Недовољан број пута
C. Индекс ван граница
D. Исправан
Ниједан баш не описује "прескаче се елемент".
Хајде да погледамо границе. `i` иде до `n-2`. `i+1` иде до `n-1`. То је ок.
Али `b[1]` није постављен.
*Модификоваћу питање 7 да буде јаснија грешка.*
Код:
```cpp
for (int i = 0; i <= n; i++)
    b[i] = ...
```
Ово је класичан buffer overflow. То је лакше за ђаке.

**8. B** (Може доћи до прекорачења...)  
**9. A** (Зато што је то већ сортиран низ...)  
**10. B** (Статичка верификација)
