<!DOCTYPE html>
<html lang="sr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Индуктивно-рекурзивна конструкција - Програмирање 2</title>
    <link rel="stylesheet" href="../../_shared/css/course-styles.css">
<link rel="stylesheet" href="../_shared/css/course-styles.css">
</head>
<body>
<main><nav><a href="../index.html">← Назад на листу лекција</a></nav><section id="id1">
<h1>Индуктивно-рекурзивна конструкција</h1>

<h2>Неке честе грешке при прављењу програма</h2>

<p>Сваки исправан програм мора да буде заснован на <strong>исправном алгоритму</strong>. Дакле, од неисправног алгоритма није могуће направити исправан програм и основна ствар приликом писања исправних програма је да се обезбеди исправност алгоритма који се примењује.</p>

<p>Са друге стране, алгоритми се описују често на апстрактнијем нивоу него што су сами програми, и многи детаљи се занемарују. Зато се услед детаља имплементације од исправног алгоритма може добити неисправан програм.</p>

<div class="problem">
<h3>Проблем комуникације</h3>
<p>Грешке у програмима често настају и због <strong>лоше комуникације</strong>. На пример:</p>
<ul>
<li>Задатак није довољно прецизно постављен</li>
<li>Онај ко захтева програм и онај ко га пише немају на уму исти задатак</li>
<li>Недовољно пажљиво читање спецификације</li>
<li>Погрешно разумевање задатка</li>
</ul>
</div>

<h3>Најчешће техничке грешке</h3>

<h4>1. Грешка погрешног избора типа</h4>

<p>Она настаје када се при писању програма одабере бројевни тип података којим се не могу исправно представити сви подаци, међурезултати и резултати.</p>

<ul>
<li>Тада при покушају уписивања неке вредности у предвиђени простор долази до <strong>прекорачења</strong> (енгл. overflow)</li>
<li>Програм даје неисправне резултате</li>
</ul>

<div class="problem">
<h3>Посебно осетљив случај</h3>
<p>Када програмер одабере тип података који може исправно да репрезентује и улазне и излазне вредности, али <strong>не и све међурезултате</strong>.</p>
<p>Такву грешку је теже приметити, а она доводи до истог проблема и неисправног резултата.</p>
</div>

<h4>2. Грешка за 1 (енгл. off by one)</h4>

<p>Типично питање код кога се чини ова грешка је:</p>

<div class="zadatak">
<h3>Примери "off by one" грешака</h3>
<ul>
<li><strong>Питање:</strong> "Стубови који носе ограду се постављају на свака два метра. Ако је ограда дуга 20 метара, колико има стубова?"<br>
<strong>Тачан одговор:</strong> 11, а не 10</li>

<li><strong>Питање:</strong> "Ако од дуже даске треба исећи пет краћих, на колико места треба сећи?"<br>
<strong>Тачан одговор:</strong> 4</li>

<li><strong>Програмерски контекст:</strong> "Потребно је обрадити елементе низа почев од индекса a, закључно са индексом b. Колико је то елемената укупно?"<br>
<strong>Тачан одговор:</strong> b-a+1</li>
</ul>
</div>

<h4>3. Прекорачење граница низа (Buffer Overflow)</h4>

<p>Грешке за 1 лако доводе до прекорачења граница низа (енгл. buffer overflow).</p>

<p><strong>Пример:</strong> Ако смо у низу одвојили место за 30 бројева, онда је могуће уписивати вредности само на позиције 0, 1, …, 29.</p>

<p>Нарочито је критична позиција 30 (тј. у општем случају позиција n за низ од n елемената). Пошто у савременим програмским језицима бројање позиција у низовима креће од нуле, на позицију n није могуће уписивати вредности.</p>

<h5>Понашање различитих језика</h5>

<table border="1">
<tr><th>Језик</th><th>Понашање при прекорачењу</th></tr>
<tr><td><strong>C++</strong></td><td>Не врши проверу опсега - недефинисано понашање</td></tr>
<tr><td><strong>C#</strong></td><td>Врши проверу и подиже изузетак</td></tr>
</table>

<div class="info-box">
<h3>Заштита од прекорачења</h3>
<p>Уколико у петљи у низ уписујемо податке чији број не знамо унапред, може бити потребно да пре сваког уписа проверимо да ли се упис врши унутар граница низа (или да користимо неки облик низа који допушта аутоматско проширивање додавањем нових елемената).</p>
</div>

<h4>4. Грешке приликом копирања</h4>

<p>Често су нам у програмима потребне две или више врло сличних наредби (или група наредби). Уобичајено је да се у таквој ситуацији одређене наредбе копирају а затим преправе.</p>

<p><strong>Проблем:</strong> Приликом преправљања се често заборавља неки детаљ, што је веома чест пропуст. Такве грешке могу да се манифестују на различите начине, зависно од тога шта смо заборавили да преправимо.</p>

<h4>5. Грешка необраћања пажње на специјалне случајеве</h4>

<p><strong>Пример:</strong> Ако у низу тражимо елемент који задовољава неки услов, неопходно је да обезбедимо да програм коректно ради и у случају када ниједан елемент не задовољава тај услов.</p>

<h5>Питања која треба решити:</h5>
<ul>
<li>Треба пажљиво прецизирати да ли функција тада треба да врати број елемената низа или, на пример, -1</li>
<li>Треба осигурати да се у коду који позива ову функционалност добро реагује на ситуацију у којој тражени елемент не постоји</li>
</ul>

<div class="problem">
<h3>Када настају специјални случајеви</h3>
<p>Специјални случајеви најчешће настају када:</p>
<ul>
<li><strong>Неке вредности не постоје</strong> (када је неки скуп чије елементе разматрамо празан)</li>
<li><strong>Улазне вредности су у неком специјалном односу</strong> (на пример, да ли геометријски програм исправно ради ако су унете тачке колинеарне)</li>
<li><strong>Међурезултати могу бити у специјалном односу</strong> - чак иако улазни параметри можда не могу бити у неком специјалном односу, међурезултати можда могу</li>
</ul>
</div>

<h2>Математичка индукција</h2>

<p><strong>Кључна идеја</strong> у конструкцији алгоритама је то да је конструкција алгоритама веома тесно повезана са доказивањем теорема математичком индукцијом.</p>

<h3>Принцип математичке индукције</h3>

<p>Математичка индукција је следећа особина природних бројева. Нека је P произвољно својство које се може формулисати у теорији природних бројева. Тада важи:</p>

<div class="info-box">
<h3>Формулација принципа</h3>
<p><strong>(P(0) ∧ (∀n)(P(n) ⇒ P(n+1))) ⇒ (∀n)(P(n))</strong></p>
</div>

<p>Дакле, да бисмо доказали да сваки природан број има неко својство P (тј. да бисмо доказали (∀n)(P(n))), довољно је да докажемо:</p>

<ol>
<li><strong>База индукције:</strong> да нула има то својство (тј. P(0))</li>
<li><strong>Индуктивни корак:</strong> да чим неки број има то својство, има га и његов следбеник (тј. да докажемо (∀n)(P(n) ⇒ P(n+1)))</li>
</ol>

<h3>Интуитивно објашњење</h3>

<p>Принцип математичке индукције је прилично јасан:</p>
<ul>
<li>На основу базе знамо да 0 има својство P</li>
<li>На основу корака да њен следбеник тј. 1 има своство P</li>
<li>На основу корака да његов следбеник тј. 2 има својство P</li>
<li>И тако даље...</li>
</ul>

<p>Интуитивно нам је јасно да на овај начин можемо стићи до било ког природног броја, који сигурно мора имати својство P.</p>

<div class="info-box">
<h3>Флексибилност базе</h3>
<p>База се може формулисати и за веће вредности од нуле, али онда само можемо да тврдимо да елементи који су већи или једнаки од базе имају својство P.</p>
</div>

<h2>Индуктивни/рекурзивни приступ</h2>

<p><strong>Основни приступ</strong> конструкцији алгоритама је тзв. индуктивни тј. рекурзивни приступ.</p>

<h3>Идеја приступа</h3>

<p>Он подразумева да се решење проблема веће димензије проналази тако што:</p>
<ul>
<li>Умемо да решимо проблем истог облика, али <strong>мање димензије</strong></li>
<li>Од решења тог проблема добијемо решење проблема <strong>веће димензије</strong></li>
<li>За почетне димензије проблема решење морамо да израчунавамо <strong>директно</strong>, без даљег свођења на проблеме мање димензије</li>
</ul>

<div class="info-box">
<h3>Гарантија заустављања</h3>
<p>Ако се приликом свођења димензија проблема увек смањује, конструисани алгоритми ће се увек заустављати.</p>
</div>

<h3>Два начина имплементације</h3>

<h4>1. Итеративна имплементација (Индуктивна)</h4>
<p>Променљиве унутар петље итеративно ажурирају своје вредности кренувши од вредности које представљају решења елементарних проблема, па до крајњих вредности које представљају решења задатог проблема.</p>

<p>Пошто је ово прилично слично принципу математичке индукције, кажемо да је алгоритам дефинисан <strong>индуктивно</strong>.</p>

<h4>2. Рекурзивна имплементација</h4>
<p>Функција која решава полазни проблем сама себе позива да би решила проблем истог облика, али мање димензије (осим у случају елементарних проблема, који се директно решавају) и тада кажемо да је алгоритам дефинисан <strong>рекурзивно</strong>.</p>

<h2>Пример: Збир елемената низа</h2>

<p>Индуктивна конструкција лежи у основи практично свих итеративних алгоритама које смо до сада разматрали.</p>

<p><strong>Пример:</strong> Алгоритам израчунавања збира серије бројева (на пример, збира елемената неког низа) почива на томе да:</p>

<ul>
<li>Знамо да израчунамо збир празне серије (то је 0)</li>
<li>Ако знамо збир серије од k елемената, тада умемо да израчунамо и збир серије која се добија проширивањем те серије додатним k+1-вим елементом</li>
<li>То радимо тако што дотадашњи збир увећамо за тај нови елемент</li>
</ul>

<pre><code>int zbir = 0;
for (int i = 0; i < a.Length; i++)
    zbir = zbir + a[i];</code></pre>

<h3>Структура индуктивног алгоритма</h3>

<p>И у овом алгоритму имамо:</p>
<ul>
<li><strong>Индуктивну базу</strong> - одговара иницијализацији променљиве пре уласка у петљу</li>
<li><strong>Индуктивни корак</strong> - одговара телу петље, у ком се ажурира вредност резултујуће променљиве</li>
</ul>

<div class="info-box">
<h3>Варијанта алгоритма</h3>
<p>База може одговарати и случају једночланог (а не обавезно празног) низа. То одговара варијанти алгоритма у којој збир иницијализујемо на први елемент низа, па га увећавамо редом за један по један елемент од позиције 1 надаље.</p>
</div>

<h2>Веза са доказивањем коректности</h2>

<p><strong>Дефинисање алгоритама индуктивно-рекурзивном конструкцијом</strong> је у веома тесној вези са доказивањем њихове коректности.</p>

<p>Иако постоје формални оквири за доказивање коректности императивних програма (пре свега <strong>Хорова логика</strong>), ми ћемо се бавити искључиво неформалним доказима и веза између логике у којој вршимо доказивање и (императивног) програмског језика у којем се програм изражава биће прилично неформална.</p>

<div class="problem">
<h3>Поједностављење за учење</h3>
<p>Приликом доказивања коректности програма обично ћемо игнорисати ограничења записа бројева у рачунару и подразумеваћемо да:</p>
<ul>
<li>Опсег бројева је неограничен</li>
<li>Реални бројеви се записују са максималном прецизношћу</li>
</ul>
<p>Дакле, нећемо обраћати пажњу на грешке које могу настати услед прекорачења или поткорачења вредности током извођења аритметичких операција.</p>
</div>

</section></main>
</body>
</html>
